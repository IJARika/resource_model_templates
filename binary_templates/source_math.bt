//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: 
//   Authors: Rika
//   Version: 
//   Purpose: Math :)
//  Category: Dependancy
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef SOURCEMATH_H
#define SOURCEMATH_H

typedef ubyte uint8;
typedef char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned int uint32_t;
typedef __int64 int64_t;
typedef __int64 intptr_t;
typedef unsigned __int64 uint64_t;
typedef unsigned __int64 size_t;

typedef hfloat float16;

// todo: Empty structure. 
struct nibble
{
    BitfieldDisablePadding();
    uint8_t bits : 4;
    BitfieldEnablePadding(); 
};

__int64 Align(__int64 a, __int64 b)
{
    return (((a)+((b)-1)) & ~((b)-1));
}

const string ReadSignedBitfield(const uint64_t bitField, const uint8_t width)
{
    if (width == 1)
        return Str("%Lu", bitField);

    // subtracting one here to get the index of our signed bit, and to get the number of our int bits
    const uint8_t adjustedWidth = width - 1;
    const uint64_t maskIntBits = (1 << (width - 1)) - 1;
    const uint64_t maskSignBit = (1 << adjustedWidth);

    local int64_t out = bitField & maskIntBits;

    if (bitField & maskSignBit)
        out = -out;

    return Str("%Ld", out);
}


// math stuff used by all structs.

// vector
struct Vector2D
{
    float x;
    float y;
};

struct Vector
{
    float x;
    float y;
    float z;
};

typedef Vector QAngle;

struct Vector4D
{
    float x;
    float y;
    float z;
    float w;
};

// packed vector
struct Vector32
{
	uint32_t x : 10;
	uint32_t y : 10;
	uint32_t z : 10;
	uint32_t exp : 2;
};

struct Vector48
{
    float16 x;
    float16 y;
    float16 z;
};

struct Vector64
{
    int64_t x : 21;
    int64_t y : 21;
    int64_t z : 22;
};

string ReadVector64(const Vector64& vec)
{
    local const int x = ((float)vec.x * 0.0009765625) - 1024.0;
    local const int y = ((float)vec.y * 0.0009765625) - 1024.0;
    local const int z = ((float)vec.z * 0.0009765625) - 2048.0;

    return Str("< %f, %f, %f >", x, y, z);    
}

// quaternion
struct Quaternion
{
    float x;
    float y;
    float z;
    float w;
};

// packed quaternion
struct Quaternion32
{
	uint32_t x : 11 <read=Str("%f", (this - 1024) * (1 / 1024.0))>;
	uint32_t y : 10 <read=Str("%f", (this - 512) * (1 / 512.0))>;
	uint32_t z : 10 <read=Str("%f", (this - 512) * (1 / 512.0))>;
	uint32_t wneg : 1;
};

const string ReadQuat32(const Quaternion32& q)
{
    const float x = ((float)q.x - 1024) * (1.0f / 1024.0);
    const float y = ((float)q.y - 512) * (1.0f / 512.0);
    const float z = ((float)q.z - 512) * (1.0f / 512.0);
    
    const float dp = ((x * x) + (y * y) + (z * z));
    const float dprem = 1.0f - dp;

    local float w = 0.0f;

    if (dprem >= 0.0f)
	    w = Sqrt(dprem);

    if (q.wneg)
        w = -w;

    return Str("< %f, %f, %f, %f >", x, y, z, w);
}

struct Quaternion48
{
	uint16_t x;
	uint16_t y;
	uint16_t z : 15;
	uint16_t wneg : 1;
};

const string ReadQuat48(const Quaternion48& q)
{
    const float x = ((float)q.x - 32768) * (1.0f / 32768.5);
    const float y = ((float)q.y - 32768) * (1.0f / 32768.5);
    const float z = ((float)q.z - 16384) * (1.0f / 16384.5);
    
    const float dp = ((x * x) + (y * y) + (z * z));
    const float dprem = 1.0f - dp;

    local float w = 0.0f;

    if (dprem >= 0.0f)
	    w = Sqrt(dprem);

    if (q.wneg)
        w = -w;

    return Str("< %f, %f, %f, %f >", x, y, z, w);
}

struct Quaternion48S
{
	uint16_t a : 15;
    uint16_t offsetH : 1;
	uint16_t b : 15;
    uint16_t offsetL : 1;
	uint16_t c : 15;
    uint16_t dneg : 1;
};

#define SCALE48S 23168.0		// needs to fit 2*sqrt(0.5) into 15 bits.
#define SHIFT48S 16384			// half of 2^15 bits.

const string ReadQuat48S(const Quaternion48S& q)
{
    float tmp[4];

    const int ia = q.offsetL + q.offsetH * 2;
	const int ib = (ia + 1) % 4;
	const int ic = (ia + 2) % 4;
	const int id = (ia + 3) % 4;
    tmp[ia] = ((float)q.a - SHIFT48S) * (1.0f / SCALE48S);
	tmp[ib] = ((float)q.b - SHIFT48S) * (1.0f / SCALE48S);
	tmp[ic] = ((float)q.c - SHIFT48S) * (1.0f / SCALE48S);

	const float dprem = (1.0 - tmp[ia] * tmp[ia] - tmp[ib] * tmp[ib] - tmp[ic] * tmp[ic]);
    tmp[id] = 0.0f;
    if (dprem >= 0.0f)
        tmp[id] = Sqrt(dprem);

	if (dneg)
		tmp[id] = -tmp[id];

    return Str("< %f, %f, %f, %f >", tmp[0], tmp[1], tmp[2], tmp[3]);
}

struct Quaternion64
{
    uint64 x : 21;
    uint64 y : 21;
    uint64 z : 21;
    uint64 wneg : 1;
};

const string ReadQuat64(const Quaternion64& q)
{
    const float x = ((float)q.x - 1048576) * (1.0f / 1048576.5);
    const float y = ((float)q.y - 1048576) * (1.0f / 1048576.5);
    const float z = ((float)q.z - 1048576) * (1.0f / 1048576.5);
    
    const float dp = ((x * x) + (y * y) + (z * z));
    const float dprem = 1.0f - dp;

    local float w = 0.0f;

    if (dprem >= 0.0f)
	    w = Sqrt(dprem);

    if (q.wneg)
        w = -w;

    return Str("< %f, %f, %f, %f >", x, y, z, w);
}

struct RadianEuler
{
    // for when you want radians in float.
    float x;
    float y;
    float z;
};

struct matrix3x4_t
{       //    c0         c1         c2         c3
		float m00; float m01; float m02; float m03; // r0
		float m10; float m11; float m12; float m13; // r1
		float m20; float m21; float m22; float m23; // r2
};

enum <int> boolean
{
    False = 0,
    True = 1,
};

typedef byte bool;

struct Color32
{
	uint8 r, g, b, a;
};

enum <uint8_t> MaterialShaderType_t
{
	RGDU = 0x0,
	RGDP = 0x1,
	RGDC = 0x2,
	SKNU = 0x3,
	SKNP = 0x4,
	SKNC = 0x5,
	WLDU = 0x6,
	WLDC = 0x7,
	PTCU = 0x8,
	PTCS = 0x9,
	RGBS = 0xA,
};

// silly guy
local int64_t i = 0;

const uint32_t popcount64 (uint64_t n) {
    n = n - ((n >> 1) & 0x5555555555555555);
    n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);
    n = (n + (n >> 4)) & 0xF0F0F0F0F0F0F0F;
    return (n * 0x101010101010101) >> 56;
}

struct FlagEntry_t
{
    local string value;
    local bool valid = false;
};

struct FlagArray_t(const int size, const string noneString)
{
    local const int length = size;
    local const string none = noneString;

    FlagEntry_t strings[length] <optimize=false>;
};

void InitFlagEntry(FlagArray_t& flagList, const string value, const uint64_t flag)
{
    const uint64_t mask = flag - 1;

    const uint32_t indice = popcount64(mask);

    flagList.strings[indice].value = value;
    flagList.strings[indice].valid = true;
}

string ReadFlags(const uint64_t flags, FlagArray_t& flagList)
{
    local string flagString = Str("(0x%lx): ", flags);

    if (!flags)
    {
        flagString += flagList.none;
        return flagString;
    }

    local bool hasFlags = false;
    for (i = 0; i < flagList.length; i++)
    {
        if (!(flags & (1 << i)))
            continue;

        if (hasFlags)
            flagString += " | ";

        if (flagList.strings[i].valid)
        {
            flagString += flagList.strings[i].value;
        }
        else
        {
            flagString += Str("unk_%lx", 1 << i);
        }
        
        hasFlags = true;
    }

    return flagString;
}

uint32_t MakeFourCC(const char ch0, const char ch1, const char ch2, const char ch3)
{
    return ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) | ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ));
}

#endif