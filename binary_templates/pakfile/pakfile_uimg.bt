//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: pakfile_uimg.bt
//   Authors: Rika
//   Version: 0.1
//   Purpose: Respawn Pak Files
//  Category: Archive
// File Mask: *.rpak
//  ID Bytes: 
//   History: 
//------------------------------------------------

const uint32_t ID_UIMG = 0x676D6975;

struct UIImageAtlasOffset_t
{
	// on negative values (i.e. -0.1), it starts to clip the image inwards while maintaining offsets.
	// More research is needed here but this seems to be what it is. Possibly to clip out garbage
	// or padding pixels generated by bakery when combining sprites?
	float cropInsetLeft;
	float cropInsetTop;

	// endX and endY define where the edge of the image is, with 1.f being the full length of the image and 0.5f being half of the image
	float endAnchorX;
	float endAnchorY;

	// startX and startY define where the top left corner is in proportion to the full image dimensions
	float startAnchorX;
	float startAnchorY;

	// changing these 2 values causes the image to be distorted on each axis
	float scaleRatioX;
	float scaleRatioY;
};

struct UIImageAtlasDimension_t
{
    uint16_t width;
    uint16_t height;
};

struct UIImageAtlasHash_v10_t
{
    uint32_t hash;
    uint16_t unk_4;
    uint16_t nameOffset;
};

struct UIImageAtlasHash_v11_t
{
    uint32_t hash;
    uint32_t nameOffset;
    uint32_t unk_8;
};

struct UIImageAtlasUV_t
{
	float minX;
	float minY;

	float sizeX;
	float sizeY;
};

struct UIImageAtlasAssetHeader_v10_t
{
	float widthRatio;
	float heightRatio;

	uint16_t width;
	uint16_t height;

	uint16_t textureCount;
	uint16_t unkCount;

	PagePtr_t textureOffsets;
	PagePtr_t textureDimensions;

	PagePtr_t unk; // unkCount of data (?)

	PagePtr_t textureHashes;
	PagePtr_t textureNames;
	uint64_t atlasGUID;
};

string ReadUIImageName(PagePtr_t& textureNames, const uint32_t hash, const uint32_t nameOffset)
{
    if (!PtrIsValid(textureNames))
        return Str("0x%x", hash);

    return ReadString(PageTell(textureNames) + nameOffset);
}

void HandleUIImageAtlas(PakAsset_t& asset, uint64_t pageoffsets[])
{
    PageSeek(asset.headPagePtr);
    switch (asset.version)
    {
    case 10:
    case 11:
    {
        UIImageAtlasAssetHeader_v10_t hdr;
        break;
    }
    };

    if (PtrIsValid(hdr.textureOffsets))
    {
        PageSeek(hdr.textureOffsets);
        UIImageAtlasOffset_t imageOffsets[hdr.textureCount];
    }

    if (PtrIsValid(hdr.textureDimensions))
    {
        PageSeek(hdr.textureDimensions);
        UIImageAtlasDimension_t imageDimensions[hdr.textureCount];
    }

    if (PtrIsValid(hdr.unk))
    {
        PageSeek(hdr.unk);
        UIImageAtlasOffset_t unk[hdr.unkCount]; // data seems to line up
    }

    if (PtrIsValid(hdr.textureHashes))
    {
        PageSeek(hdr.textureHashes);
        switch (asset.version)
        {
        case 10:
        {
            UIImageAtlasHash_v10_t imageHashes[hdr.textureCount];
            break;
        }
        case 11:
        {
            UIImageAtlasHash_v11_t imageHashes[hdr.textureCount];
            break;
        }
        };
        
    }

    if (PtrIsValid(hdr.textureNames) && exists(imageHashes))
    {
        local const int lastOffset = imageHashes[hdr.textureCount - 1].nameOffset;
        local const string lastString = ReadString(PageTell(hdr.textureNames) + lastOffset);

        PageSeek(hdr.textureNames);
        char textureNames[lastOffset + Strlen(lastString) + 1];
    }

    PageSeek(asset.dataPagePtr);
    UIImageAtlasUV_t textureUVs[hdr.textureCount];
}