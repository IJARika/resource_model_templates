//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: rmdl, rrig
//   Authors: Valve, Rika, & Others
//   Version: 54
//   Purpose: Respawn MDL Structs
//  Category: Struct
// File Mask: *.rmdl, *.rrig
//  ID Bytes: 
//   History: 
//------------------------------------------------

#define MAX_NUM_LODS 8

//local int i = 0;

// these are just all structs that I have mostly working/fitting, it does not mean they are correct.
// a lot of these are from either valvedevwiki, the public source sdk 2013 code, and crowbar.


//========
// Headers


// main headers
struct studiohdr_t_v54
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex <read=ReadString(startof(this) + this - 12)>; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	                // Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.
 
	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
	rmdlflags_t flags;
  
	int numbones; // bones
	int boneindex;
 
	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
	int numhitboxsets;
	int hitboxsetindex;
 
    // unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
	int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
 
	// mstudiotexture_t
	// short rpak path
	// raw textures
    int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
	int numlocalattachments;
	int localattachmentindex;
 
	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
	int numflexdesc;
	int flexdescindex;
 
	int meshindex; // SubmeshLodsOffset, might just be a mess offset

	int numflexcontrollers;
	int flexcontrollerindex;
 
	int numflexrules;
	int flexruleindex;
 
	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;
 
	int numlocalposeparameters;
	int localposeparamindex;
 
	int surfacepropindex <read=ReadString(startof(mdlHeader) + mdlHeader.surfacepropindex)>;
 
	int keyvalueindex;
	int keyvaluesize;
 
	int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
	float mass;
	int contents <read=ReadContents(this)>;
	
	// unused for packed models
	int numincludemodels;
	int includemodelindex;
	
	uint32 virtualModel;

	int bonetablebynameindex;
	
	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance;
	
	float gathersize; // what. from r5r struct

    int numunk_v54_early;
    int unkindex_v54_early;

	int unk_v54[2];

	// this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
	int mayaindex; // doesn't actually need to be written pretty sure, only four bytes when not present.

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;
	
	int linearboneindex;

	int m_nBoneFlexDriverCount; // unsure if that's what it is in apex
	int m_nBoneFlexDriverIndex;
	
    int unkindexflex;

	int unk1_v54[6];

	// always "" or "Titan"
    int unkstringindex <read=ReadString(startof(mdlHeader) + mdlHeader.unkstringindex)>;

	// this is now used for combined files in rpak, vtx, vvd, and vvc are all combined while vphy is separate.
	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize; // still used in models using vg

	// unk2_v54[3] is the chunk after following unkindex2's chunk
	int unk2_v54[3]; // the same four unks in v53 I think, the first index being unused now probably

    int unkindex3; // index to chunk after string block

    // Per Tri Collision AABB size
    Vector3 mins;
    Vector3 maxs; // seem to be the same as hull size

    int unk3_v54[3];

	int unkindex4; // chunk before unkindex3 sometimes

	int unk4_v54[3]; // same as unk3_v54_v121

    //int vgindex; // 0tVG
    //int unksize; // might be offset
    //int unksize1; // might be offset

};

struct studiohdr_t_v54_v121
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex <read=ReadString(startof(this) + this - 12)>; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	                // Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.
 
	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
	rmdlflags_t flags;
  
	int numbones; // bones
	int boneindex;
 
	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
	int numhitboxsets;
	int hitboxsetindex;
 
	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
	int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
 
	// mstudiotexture_t
	// short rpak path
	// raw textures
    int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
	int numlocalattachments;
	int localattachmentindex;
 
	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
	// these are unknown since I don't know what they cut
	int numunk_v121;
	int unkindex_v121;

	int numikchains;
	int ikchainindex;
 
	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;
 
	int numlocalposeparameters;
	int localposeparamindex;
 
	int surfacepropindex <read=ReadString(startof(mdlHeader) + mdlHeader.surfacepropindex)>;
 
	int keyvalueindex;
	int keyvaluesize;
 
	int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
	float mass;
	int contents <read=ReadContents(this)>;
	
	// unused for packed models
	int numincludemodels;
	int includemodelindex;
	
	uint32 virtualModel;

	int bonetablebynameindex;

	int numunk1_v121;
	int unkindex1_v121;

    int boneremapindex;
    int numboneremaps;

    int unk_v54_v121[4];

    // section before bone remaps
    int unkindex2_v121;
    int numunk2_v121;

    // section before above section
	int unkindex3_v121;
    int numunk3_v121;

    float fadedistance;
	
	float gathersize; // what. from r5r struct
	
	int unk_v54[2];

    // asset bakery strings if it has any
	int mayaindex;

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

    int numboneflexdrivers; // unsure if that's what it is in apex
	int boneflexdriverindex;

    int unkindexflex;

	int unk3_v54_a; // I think this section was split vs old v54

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

    int unk3_v54_b; // second part of above

    int unkindex3; // index to chunk after string block

    // Per Tri Collision AABB size
    Vector3 mins;
    Vector3 maxs; // seem to be the same as hull size

    int unkindex4; // chunk before unkindex2 sometimes

    int unk4_v54[3];
};

struct studiohdr_t_v54_v122
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex <read=ReadString(startof(this) + this - 12)>; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	                // Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.
 
	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
	rmdlflags_t flags;
  
	int numbones; // bones
	int boneindex;
 
	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
	int numhitboxsets;
	int hitboxsetindex;
 
	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
	int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
 
	// mstudiotexture_t
	// short rpak path
	// raw textures
    int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
	int numlocalattachments;
	int localattachmentindex;
 
	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
	// these are unknown since I don't know what they cut
	int numunk_v121;
	int unkindex_v121;

	int numikchains;
	int ikchainindex;
 
	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;
 
	int numlocalposeparameters;
	int localposeparamindex;
 
	int surfacepropindex <read=ReadString(startof(mdlHeader) + mdlHeader.surfacepropindex)>;
 
	int keyvalueindex;
	int keyvaluesize;
 
	int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
	float mass;
	int contents <read=ReadContents(this)>;
	
	// unused for packed models
	int numincludemodels;
	int includemodelindex;
	
	uint32 virtualModel;

	int bonetablebynameindex;

	int numunk1_v121;
	int unkindex1_v121;

    int boneremapindex;
    int numboneremaps;

    int unk_v54_v121[4];

    // section before bone remaps
    int unkindex2_v121;
    int numunk2_v121;

    // section before above section
	int unkindex3_v121;
    int numunk3_v121;

    float fadedistance;
	
	float gathersize; // what. from r5r struct
	
	int unk_v54[2];

    int unk_v122;

    // asset bakery strings if it has any
	int mayaindex;

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

    int numboneflexdrivers; // unsure if that's what it is in apex
	int boneflexdriverindex;

	int unkindexflex;

	int unk3_v54_a; // I think this section was split vs old v54

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

    int unk3_v54_b; // second part of above

    int unkindex3; // index to chunk after string block

    // Per Tri Collision AABB size
    Vector3 mins;
    Vector3 maxs; // seem to be the same as hull size

    int unkindex4; // chunk before unkindex2 sometimes

    int unk4_v54[3];
};

struct studiohdr_t_v54_v13
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex <read=ReadString(startof(this) + this - 12)>; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	                // Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.
 
	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
	rmdlflags_t flags;
  
	int numbones; // bones
	int boneindex;
 
	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
	int numhitboxsets;
	int hitboxsetindex;
 
	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
	int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
 
	// mstudiotexture_t
	// short rpak path
	// raw textures
    int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
	int numlocalattachments;
	int localattachmentindex;
 
	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
	// these are unknown since I don't know what they cut
	int numunk_v121;
	int unkindex_v121;

	int numikchains;
	int ikchainindex;
 
	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;
 
	int numlocalposeparameters;
	int localposeparamindex;
 
	int surfacepropindex <read=ReadString(startof(mdlHeader) + mdlHeader.surfacepropindex)>;
 
	int keyvalueindex;
	int keyvaluesize;
 
	int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
	float mass;
	int contents <read=ReadContents(this)>;
	
	// unused for packed models
	int numincludemodels;
	int includemodelindex;
	
	uint32 virtualModel;

	int bonetablebynameindex;

	int numunk1_v121;
	int unkindex1_v121;

    int boneremapindex;
    int numboneremaps;

    int unk_v54_v121[4];

    // section before bone remaps
    int unkindex2_v121;
    int numunk2_v121;

    // section before above section
	int unkindex3_v121;
    int numunk3_v121;

    float fadedistance;
	
	float gathersize; // what. from r5r struct
	
	int unk_v54[2];

    int unk_v54_v122; // added in transition version

    // asset bakery strings if it has any
	int mayaindex;

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

    int numboneflexdrivers; // unsure if that's what it is in apex
	int boneflexdriverindex;

	int unkindexflex;

	int unk3_v54_a; // I think this section was split vs old v54

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

    int unk3_v54_b; // second part of above

    int unkindex3; // index to chunk after string block

    // Per Tri Collision AABB size
    Vector3 mins;
    Vector3 maxs; // seem to be the same as hull size

    int unkindex4; // chunk before unkindex2 sometimes

    int unk4_v54[3];

    int unk1_v54_v13[3];
};

struct studiohdr_t_v54_v14
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex <read=ReadString(startof(this) + this - 12)>; // No longer stored in string block, uses string in header.
	char name[64]; // The internal name of the model, padding with null bytes.
	                // Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.
 
	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
	rmdlflags_t flags;
  
	int numbones; // bones
	int boneindex;
 
	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
	int numhitboxsets;
	int hitboxsetindex;
 
	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
	int numlocalseq; // sequences
	int	localseqindex;

    int unk_v54_v14[2]; // added in v13 -> v14
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
 
	// mstudiotexture_t
	// short rpak path
	// raw textures
    int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
	int numlocalattachments;
	int localattachmentindex;
 
	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
	// these are unknown since I don't know what they cut
	int numunk_v121;
	int unkindex_v121;

	int numikchains;
	int ikchainindex;
 
	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;
 
	int numlocalposeparameters;
	int localposeparamindex;
 
	int surfacepropindex <read=ReadString(startof(mdlHeader) + mdlHeader.surfacepropindex)>;
 
	int keyvalueindex;
	int keyvaluesize;
 
	int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
	float mass;
	int contents <read=ReadContents(this)>;
	
	// unused for packed models
	int numincludemodels;
	int includemodelindex;
	
	uint32 virtualModel;

	int bonetablebynameindex;

	int numunk1_v121;
	int unkindex1_v121;

    int boneremapindex;
    int numboneremaps;

    int unk_v54_v121[4];

    // section before bone remaps
    int unkindex2_v121;
    int numunk2_v121;

    // section before above section
	int unkindex3_v121;
    int numunk3_v121;

    float fadedistance;
	
	float gathersize; // what. from r5r struct
	
	int unk_v54[2];

    int unk_v54_v122; // added in transition version

    // asset bakery strings if it has any
	int mayaindex;

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

    int numboneflexdrivers; // unsure if that's what it is in apex
	int boneflexdriverindex;

	int unkindexflex;

	int unk3_v54_a; // I think this section was split vs old v54

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

    int unk3_v54_b; // second part of above

    int unkindex3; // index to chunk after string block

    // Per Tri Collision AABB size
    Vector3 mins;
    Vector3 maxs; // seem to be the same as hull size

    int unkindex4; // chunk before unkindex2 sometimes

    int unk4_v54[3];

    int unk1_v54_v13[3];
};


//=============
// Bone Structs


/*
#define BONE_CALCULATE_MASK			0x1F
#define BONE_PHYSICALLY_SIMULATED	0x01	// bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL		0x02	// procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL		0x04	// bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE	0x08	// bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER	0x10	// bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK				0x0007FF00
#define BONE_USED_BY_ANYTHING		0x0007FF00
#define BONE_USED_BY_HITBOX			0x00000100	// bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT		0x00000200	// bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK	0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0	0x00000400	// bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1	0x00000800	
#define BONE_USED_BY_VERTEX_LOD2	0x00001000  
#define BONE_USED_BY_VERTEX_LOD3	0x00002000
#define BONE_USED_BY_VERTEX_LOD4	0x00004000
#define BONE_USED_BY_VERTEX_LOD5	0x00008000
#define BONE_USED_BY_VERTEX_LOD6	0x00010000
#define BONE_USED_BY_VERTEX_LOD7	0x00020000
// bone merge unused?

#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define MAX_NUM_LODS 8

#define BONE_TYPE_MASK				0x00F00000

// might be different in v54
#define BONE_FIXED_ALIGNMENT		0x00100000	// bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation

#define BONE_HAS_SAVEFRAME_POS		0x00200000	// Vector48
#define BONE_HAS_SAVEFRAME_ROT64	0x00400000	// Quaternion64
#define BONE_HAS_SAVEFRAME_ROT32	0x00800000	// Quaternion32
*/

// bones
// v54 is a heavily gutted v53 bone
struct mstudiobone_t_v54
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	
	Vector3 unkvector; // the same as whatever v53 is

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone
	
    int surfacepropidx <read=ReadString(startof(this) + this - 164)>; // index into string tablefor property name

	int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags

    int unk; // similar value in studiohdr
	
	int surfacepropLookup; // unsure, the normal spot has data though
	
	int unkid; // id is for unk section after stringblock, lacks toggle
};

struct mstudiobone_t_v54_v121
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	
	Vector3 unkvector; // the same as whatever v53 is

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone
	
    int surfacepropidx <read=ReadString(startof(this) + this - 164)>; // index into string tablefor property name

	int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags
	
	int unk; // similar value in studiohdr

    int unkid; // id is for unk section after stringblock, lacks toggle
};

// jigglebone
struct mstudiojigglebone_t_v54
{
    byte flags; // looks to be.

    int16 bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // id of bone, might be single byte

    byte unused; // possibly unused

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

    float unkfloat; // v54 adds an extra value here but otherwise the same
                    // observed values are between 0-1

	// flexible params
	float yawStiffness;
	float yawDamping;	
	float pitchStiffness;
	float pitchDamping;	
	float alongStiffness;
	float alongDamping;	

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians
	
	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;
	
	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;	
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

// attachment
struct mstudioattachment_t_v54
{
	int sznameindex <read=ReadString(startof(this) + this)>;
	int flags;

	int localbone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // parent bone

	matrix3x4_t			localmatrix; // attachment point
};

// ikchain
struct mstudioikchain_t_v54
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int linktype;
	int numlinks;
	int linkindex;
    
    float unk; // no clue what this does tbh, tweaking it does nothing
               // default value: 0.707f
};

// ikinfo
struct mstudioiklink_t_v54
{
	uint32 bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
	Vector3	unused0; // no kneeDir in apex I think
};

// linear bone

struct mstudiolinearbone_t_v54
{
    // they cut pos and rot scale, understandable since posscale was never used it tf|2 and they do anims different in apex
	int numbones;

	int flagsindex;

	int	parentindex;
	
	int	posindex;
	
	int quatindex;
	
	int rotindex;
	
	int posetoboneindex;
};

// bone remaps
struct mstudioboneremaptable_t
{
    for(i = 0; i < mdlHeader.numboneremaps; i++)
        ubyte bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
};


//===============
// Hitbox Structs


// hit box boxes
struct mstudiobbox_t_v54
{
	int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
	hboxgroup group; // intersection group

	Vector3 bbmin; // bounding box
	Vector3 bbmax;	

	int szhitboxnameindex <read=ReadString(startof(this) + this - 32)>; // offset to the name of the hitbox.
    
    int critoverride; // overrides the group to be a crit, 0 or 1. might be group override since group 1 is head.

    int keyvalueindex <read=ReadString(startof(this) + this - 40)>; // used for keyvalues, most for titans.
};


//==================
// Animation Structs


// anim descriptions
struct mstudioanimdesc_t_v54
{
	int baseptr;

	int sznameindex <read=ReadString(startof(parentof(this)) + this)>;

	float fps; // frames per second	
	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int nummovements;
	int movementindex;

	int compressedikerrorindex;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used
};

// rseq v7.1
struct mstudioanimdesc_t_v54_v121
{
	int baseptr;

	int sznameindex <read=ReadString(startof(parentof(this)) + this)>;

	float fps; // frames per second	
	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int nummovements;
	int movementindex;

	int compressedikerrorindex;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl

	int sectionindex;

    int unk; // what

    int sectionframes; // number of frames used in each fast lookup section, zero if not used

    

    int unk1; // Padding
    int unk2; // Padding
    int unk3; // SomeDataOffset
    int unk4; // SomeDataOffset

    // it seems like there's another int here but I'm unsure
};

struct mstudioanimsections_t_v54_v121
{
	int animindex;
    int isExternal; // 0 or 1, if 1 section is not in rseq (I think)
};

struct sectionindexes_t_v54_v121
{
    mstudioanimsections_t_v54_v121 sectionoffsets[(animdesc[i].numframes / animdesc[i].sectionframes) + 2] <bgcolor=cLtBlue>;
};

struct animflagarray_t_v54
{   
    // don't think this is correct
    byte STUDIO_ANIM_POS_54 : 1;
    byte STUDIO_ANIM_ROT_54 : 1;
    byte STUDIO_ANIM_SCALE_54 : 1;
    byte STUDIO_ANIM_UNK_54 : 1;    
};

struct boneflagarray_t
{

    BitfieldDisablePadding();
    animflagarray_t_v54 boneflag[mdlHeader.numbones] <bgcolor=0xaa8822, optimize=false>;
    BitfieldEnablePadding();

    byte padd[(4 - (mdlHeader.numbones % 4)) / 2] <bgcolor=0xaaaa22>;
};

// for rseq templates because no mdlHeader
struct boneflagarray_t_loose
{
    BitfieldDisablePadding();
    animflagarray_t_v54 boneflag[numbones] <bgcolor=0xaa8822, optimize=false>;
    BitfieldEnablePadding();

    // breaks sometimes
    byte padd[(4 - (numbones % 4)) / 2] <bgcolor=0xaaaa22>;
};

// not correct
struct mstudioanim_valueptr_t_v54
{
    uint x : 8;
    uint y : 8;
    uint z : 8; 
    uint unk : 8;
};

#define STUDIO_ANIM_DELTA_54	 0x01 // unverified
#define STUDIO_ANIM_ANIMSCALE_54 0x02 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMROT_54	 0x04 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMPOS_54	 0x08 // mstudioanim_valueptr_t

string ReadAnimFlagsV54(byte flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    byte flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case STUDIO_ANIM_DELTA_54:
            value += "STUDIO_ANIM_DELTA_54";
            break;
        case STUDIO_ANIM_ANIMSCALE_54:
            value += "STUDIO_ANIM_ANIMSCALE_54";
            break;
        case STUDIO_ANIM_ANIMROT_54:
            value += "STUDIO_ANIM_ANIMROT_54";
            break;
        case STUDIO_ANIM_ANIMPOS_54:
            value += "STUDIO_ANIM_ANIMPOS_54";
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

struct mstudio_rle_anim_t_v54
{

	int16 size : 12; // total size of all animation data

    //int16 STUDIO_ANIM_UNK_54 : 1; // probably delta
    //int16 STUDIO_ANIM_ANIMSCALE_54 : 1;    
    //int16 STUDIO_ANIM_ANIMROT_54 : 1;
    //int16 STUDIO_ANIM_ANIMPOS_54 : 1;

    int16 flags : 4 <read=ReadAnimFlagsV54(this)>;
    
    if(flags & STUDIO_ANIM_ANIMPOS_54)
        float posscale;

    if(flagarray.boneflag[j].STUDIO_ANIM_POS_54)
    {
        if(flags & STUDIO_ANIM_ANIMPOS_54)
            mstudioanim_valueptr_t_v54 animpos;
        else
            Vector48 rawpos;
    }

    if(flagarray.boneflag[j].STUDIO_ANIM_ROT_54)
    {
        if(flags & STUDIO_ANIM_ANIMROT_54)
            mstudioanim_valueptr_t_v54 animrot;
        else
            Quat64 rawrot;
    }

    if(flagarray.boneflag[j].STUDIO_ANIM_SCALE_54)
    {
        if(flags & STUDIO_ANIM_ANIMSCALE_54)
            mstudioanim_valueptr_t_v54 animscale;
        else
            Vector48 rawscale;
    }
};

struct mstudioikrule_t_v54
{
    int index;
    ikruletype type;
    int chain;
    int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;

    int slot; // iktarget slot. Usually same as chain.
    float height;
    float radius;
    float floor;
    Vector3 pos;
    Quaternion q;

    // in later versions this is scale, that also might apply here
    int unk[7]; // might be before pos and q

    int compressedikerrorindex;

    int iStart;
    int ikerrorindex;

    float start; // beginning of influence
    float peak; // start of full influence
    float tail; // end of full influence
    float end; // end of all influence

    float contact; // frame footstep makes ground concact
    float drop; // how far down the foot should drop when reaching for IK
    float top; // top of the foot box

    int szattachmentindex; // name of world attachment

    int unk; // there is an int here in apex and 9 unused doesn't make sense.

    
};

struct mstudioikrule_t_v54_new
{
    int index;
    ikruletype type;
    int chain;
    int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;

    int slot; // iktarget slot. Usually same as chain.
    float height;
    float radius;
    float floor;
    Vector3 pos;
    Quaternion q;

    float scale[6]; // these values are the same as what posscale (if it was used) and rotscale are.
	//int16 offset[6];

    int unk1[3];

    //int compressedikerrorindex;

    int iStart;
    //int ikerrorindex;

    float start; // beginning of influence
    float peak; // start of full influence
    float tail; // end of full influence
    float end; // end of all influence

    float contact; // frame footstep makes ground concact
    float drop; // how far down the foot should drop when reaching for IK
    float top; // top of the foot box

    int szattachmentindex; // name of world attachment

    int unk;

    //int unused[9];
};


struct mstudiocompressedikerror_t_v54
{
	float scale[4]; // first three values are the same as what posscale (if it was used) is, fourth is similar to unkvector1.
    // unknown how this works now
	//int offset[9];
};

// seq descriptions
struct mstudioseqdesc_t_v54
{
	int baseptr;

	int	szlabelindex <read=ReadString(startof(this) + this - 4)>;

	int szactivitynameindex <read=ReadString(startof(this) + this - 8)>;

	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector3 bbmin; // per sequence bounding box
	Vector3 bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

	int unk;
    int unk1;

    int unkindex;

    int unk2;
};

struct mstudioautolayer_t_v54
{
    int64 guid; // hashed aseq guid asset

	short iSequence;
	short iPose;

	int flags <read=ReadAutoLayerFlags(this)>;
	float start;	// beginning of influence
	float peak;	// start of full influence
	float tail;	// end of full influence
	float end;	// end of all influence
};

struct mstudioevent_t_v54
{
	float cycle;
	int	event;
	eventtype type; // this will be 0 if old style I'd imagine
	char options[256];

	int szeventindex <read=ReadString(startof(parentof(this)) + this)>;
};

// rseq v10
struct mstudioevent_t_v54_122
{
	float cycle;
	int	event;
	eventtype type; // this will be 0 if old style I'd imagine
	char options[256]; // this is the only difference compared to normal v54

    int unk;

	int szeventindex <read=ReadString(startof(parentof(this)) + this)>;
};

struct blendgroup_t_v54
{
    // this is an offset now
    int blends[seqdesc[i].groupsize[0] * seqdesc[i].groupsize[1]];
};


//===================
// Model/Mesh Structs


// bodyparts
struct mstudiobodyparts_t_v54_v15
{
	int sznameindex;
	int nummodels;
	int base;
	int modelindex; // index into models array

    int unk;
    int meshindex; // start of meshes?
};

// studio models
struct mstudiomodel_t_v54
{
	char name[64];

	int unkindex2 <read=ReadString(startof(this) + this - 64)>; // goes to bones sometimes

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

    // same as v53, except trimming the fat
	int unk[4];

    int unkindex;
    int unkindex1;
};

struct mstudiomodel_t_v54_v121
{
	char name[64];

	int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

    // same as v53, except trimming the fat
	//int unk;

    //int unkindex;
    //int unkindex1;
};

struct mstudiomodel_t_v54_v13
{
	char name[64];

	int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

    // same as v53, except trimming the fat
	int unk;

    //int unkindex;
    //int unkindex1;
};

struct mstudiomodel_t_v54_v14
{
	char name[64];

	int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

    // same as v53, except trimming the fat
	int unk[3]; // bruh

    //int unkindex;
    //int unkindex1;
};

struct mstudiomodel_t_v54_v15
{
	char name[64];

	int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

	float boundingradius;

	int nummeshes;

    int unk1[2]; // first is the same as nummeshes?

	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

    // same as v53, except trimming the fat
	int unk; // bruh

    //int unkindex;
    //int unkindex1;
};

// meshes
struct mstudiomesh_t_v54
{
	int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)
	
	int numflexes; // vertex animation
	int flexindex;


	// special codes for material operations
	int materialtype;
	int materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	mstudio_meshvertexdata_t vertexdata;
    
	int unused[2];
};

struct mstudiomesh_t_v54_v121
{
	int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t
	
	// a unique ordinal for this mesh
	int meshid;

    Vector3 center;

	// a unique ordinal for this mesh
	//int meshid;

	mstudio_meshvertexdata_t vertexdata;
    
	int unused[2];
};


//=================
// Material Structs


// skin info
struct mstudiotexture_t_v54
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int64 guid;
};

// texture types, new in v54
enum <byte> MaterialShaderType_t
{
  RGDU = 0x0,
  RGDP = 0x1,
  RGDC = 0x2,
  SKNU = 0x3,
  SKNP = 0x4,
  SKNC = 0x5,
  WLDU = 0x6,
  WLDC = 0x7,
  PTCU = 0x8,
  PTCS = 0x9,
};


//====
// RUI


struct mstudioruivertmapv54_t
{
    // not sure of the order on these
    int16 vertid1;
    int16 vertid2;
    int16 vertid3;
};

struct mstudioruifourthvertv54_t
{
    // not sure of the order on these
    int16 vertid4;
};

struct mstudioruimeshv54_t
{
    int16 numparents; // apparently you can have meshes parented to more than one bone(?)
    int16 numvertices; // number of verts
    int16 numfaces; // number of faces (quads)

    int16 unk;

    int parentindex; // this gets padding out front of it to even off the struct

    int vertexindex; // offset into smd style vertex data
    int fourthvertmapindex; // they now fully map the vertices for each quad
    int vertmapindex; // offsets into a vertex map for each quad
    int facedataindex; // offset into uv section

    char szruimeshname[parentindex - 28]; // have to subtract header to get actual size (padding included)

    int16 parent[numparents] <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // parent(s) bone of mesh

    mstudioruivertmapv54_t vertexmap[numfaces]; // vertex map for each face
    mstudioruifourthvertv54_t fourthvertmap[numfaces];
    mstudioruivert_t vertex[numvertices];

    mstudioruimesface_t facedata[numfaces];
};


//========
// Unknown

struct unkheader_v54
{
    int dataindex1;
    int dataindex2;
    int dataindex3;

    int numsection;
};

struct unksectionheader_v54
{
    int unk;

    int dataindex1;
    int dataindex2;
    int dataindex3;

    float unkfloat[3]; // unsure if this is a vector

    int unk1;
};

// v12
struct unksectionheader_v54_v12
{
    int unk;

    int dataindex1;
    int dataindex2;
    int dataindex3;

    int dataindex4; // new

    int unknew;

    float unkfloat[3]; // unsure if this is a vector

    hfloat unk1[2]; // sus
};

struct unkheaderdata_v54
{
    int unk[2];
    int unk1;
    int unk2;
};

// for sections near bone remap in 12.1 plus

// lod related maybe
struct unkindex3sect
{
    int16 unkid[4]; // always very clean numbers, mesh lod map?

    float threshold;

    int unk;
};

struct unkindex2sect
{
    // if we take this as an offset and size there is 13 bytes between each section.
    int unkoffset; // offset?
    int unksize; // size?

    int16 unk1[4]; // ids for something
};

struct unkindex1sect
{
    int unk[2];

    float unkfloat;

    int unk1[9];
};


//=====
// Misc


struct mstudionode_t_v54
{
    int sznameindex[mdlHeader.numlocalnodes];

    int nodeindex[mdlHeader.numlocalnodes];
};