//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl
//   Authors: Rika
//   Version: 48/49/52
//   Purpose: Valve/Respawn MDL Files
//  Category: Model
// File Mask: *.mdl
//  ID Bytes: 
//   History: 
//------------------------------------------------


#include "../source_math.bt"
#include "../mdl/mdl_structs.bt"

local int i = 0;
local int j = 0;
local int k = 1;
local int x = 0;


// version before the header is created.
local int pre_version = ReadInt(4);


// headers
if (pre_version == 52)
{ 
    studiohdr_t_v52 mdlHeader <bgcolor=cLtBlue, read=ReadString(startof(mdlSubHeader) + mdlSubHeader.sznameindex)>;
    studiohdr2_t_v52 mdlSubHeader <bgcolor=cDkBlue>;

    // this is a check for non shipped models.
    // this isn't essential for models to function, however when not present it should be four bytes instead of just nothing.
    if (mdlHeader.boneindex > mdlHeader.mayaindex && mdlHeader.mayaindex != 0)
        char mayabakery[mdlHeader.boneindex - mdlHeader.mayaindex] <fgcolor=cRed>;
}
else if (pre_version == 49)
{
    studiohdr_t_v49 mdlHeader <bgcolor=cLtBlue, read=ReadString(startof(mdlSubHeader) + mdlSubHeader.sznameindex)>;
    studiohdr2_t mdlSubHeader <bgcolor=cDkBlue>;
}
else
{
    studiohdr_t_v48 mdlHeader <bgcolor=cLtBlue, read=ReadString(startof(mdlSubHeader) + mdlSubHeader.sznameindex)>;
    studiohdr2_t mdlSubHeader <bgcolor=cDkBlue>;
}


// bones
FSeek(mdlHeader.boneindex);
if (mdlHeader.version == 52)
    mstudiobone_t_v52 bones[mdlHeader.numbones] <bgcolor=cLtGreen, read=ReadString(startof(this) + this.sznameindex)>;
else if (mdlHeader.version == 49)
    mstudiobone_t_v49 bones[mdlHeader.numbones] <bgcolor=cLtGreen, read=ReadString(startof(this) + this.sznameindex)>;
else
    mstudiobone_t_v47 bones[mdlHeader.numbones] <bgcolor=cLtGreen, read=ReadString(startof(this) + this.sznameindex)>;

local int jigglebonecount = 0;

local char s_jigglebonename;

for (i = 0; i < mdlHeader.numbones; ++i)
{
    if (bones[i].proctype == 5) {
        jigglebonecount++;
    }
}

mstudiojigglebone_t jigglebones[jigglebonecount] <bgcolor=cGreen>;

FSeek(mdlHeader.localattachmentindex);
mstudioattachment_t attachments[mdlHeader.numlocalattachments] <bgcolor=0xcff5ca, read=Str("%s : %s", ReadString(startof(this) + this.sznameindex), ReadString(startof(bones[this.localbone]) + bones[this.localbone].sznameindex))>;


// hitbox
FSeek(mdlHeader.hitboxsetindex);
mstudiohitboxset_t hboxset[mdlHeader.numhitboxsets] <bgcolor=0xf2e46a, read=ReadString(startof(this) + this.sznameindex)>;

// have to do this because some things actually do have more than one.
local int hboxCount = 0;

for (i = 0; i < mdlHeader.numhitboxsets; ++i)
{
   hboxCount += hboxset[i].numhitboxes;
};

mstudiobbox_t bboxes[hboxCount] <bgcolor=0xa29418, read=ReadString(startof(this) + this.szhitboxnameindex)>;


// more bones
FSeek(mdlHeader.bonetablebynameindex);
mstudiobonenametable_t bonenames <bgcolor=cDkGreen>;


// animation
FSeek(mdlHeader.localanimindex);
if (mdlHeader.version < 49)
    mstudioanimdesc_t_v48 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;
else if(mdlHeader.version == 49)
    mstudioanimdesc_t_v49 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;
else
    mstudioanimdesc_t_v52 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;


// Animation Data
local int numanimboneheader = 0;
local int numsectionanimboneheader = 0;
local int numikrule = 0;
local int numsections = 0;
local int sectionlength = 0;

for (i = 0; i < mdlHeader.numlocalanim; ++i)
{
	if(animdesc[i].sectionframes > 0)
    {
        FSeek(startof(animdesc[i]) + animdesc[i].sectionindex);
        sectionindexes_t sectionindexes;
        numsections++;
        sectionlength = (animdesc[i].numframes / animdesc[i].sectionframes) + 2;

        for(j = 0; j < sectionlength; j++)
        {
            FSeek(startof(animdesc[i]) + sectionindexes[numsections - 1].sectionoffsets[j].sectionoffset);

            for (k = 0; k < mdlHeader.numbones; ++k)
            {   
                mstudioanim_t sectionanimheader <bgcolor=(this.nextoffset == 0 ? 0xFF1122 : 0x771122 )>;
                numsectionanimboneheader += 1;
                FSeek(startof(sectionanimheader[numsectionanimboneheader - 1]));
                FSkip(sectionanimheader[numsectionanimboneheader - 1].nextoffset);

                if (sectionanimheader[numsectionanimboneheader - 1].nextoffset <= 0) 
		        {
			        break;
		        }
            };
        };
    }

	if(animdesc[i].sectionframes == 0)
    {
        FSeek(animdesc[i].animindex - animdesc[i].baseptr);
	    for (j = 0; j < mdlHeader.numbones; ++j)
	    {
            
		    mstudioanim_t animheader <bgcolor=(this.nextoffset == 0 ? cDkBlue : cBlue )>;
		    numanimboneheader += 1;
            FSeek(startof(animheader[numanimboneheader - 1]));
            FSkip(animheader[numanimboneheader - 1].nextoffset);
            
		    if (animheader[numanimboneheader - 1].nextoffset <= 0) 
		    {
			    // Read in unused empty data structure at the end of the list.
			    //RAnimBoneHeader animBoneHeaders <bgcolor=cDkBlue>;
			    break;
		    }
	    };
    }

	// Animation IK Rules
	FSeek(animdesc[i].ikruleindex - animdesc[i].baseptr);
	for (j = 0; j < animdesc[i].numikrules; ++j)
	{
		mstudioikrule_t animikrule <bgcolor=cGreen>;
		numikrule += 1;
	};

    for(j = -animdesc[i].numikrules; j < 0; j++)
    {
        if(animikrule[numikrule + j].compressedikerrorindex > 0)
        {
            FSeek(startof(animikrule[numikrule + j]) + animikrule[numikrule + j].compressedikerrorindex);
            mstudiocompressedikerror_t ikcompressederror <bgcolor=cDkGreen>;
        }
    }

    if(mdlHeader.version == 52)
    {
        if(animdesc[i].compressedikerrorindex > 0)
        {
            FSeek(startof(animdesc[i]) + animdesc[i].compressedikerrorindex);
            mstudiocompressedikerror_t_v52 ikcompressederrorNEW <bgcolor=cLtGreen>;
        }
    }
};


FSeek(mdlHeader.localseqindex);
if (mdlHeader.version < 49)
    mstudioseqdescv48_t seqdesc[mdlHeader.numlocalseq] <bgcolor=0xf0b27a, read=Str("%s : %s", ReadString(startof(this) + this.szlabelindex), ReadString(startof(this) + this.szactivitynameindex))>;
else
    mstudioseqdescv49_t seqdesc[mdlHeader.numlocalseq] <bgcolor=0xf0b27a, read=Str("%s : %s", ReadString(startof(this) + this.szlabelindex), ReadString(startof(this) + this.szactivitynameindex))>;


for(i = 0; i < mdlHeader.numlocalseq; i++)
{
    if(seqdesc[i].posekeyindex > 0)
    {
        FSeek(startof(seqdesc[i]) + seqdesc[i].posekeyindex);
        posekey_t posekey <bgcolor=0x55ee00>;
    }

    if(seqdesc[i].numevents > 0)
    {
        FSeek(startof(seqdesc[i]) + seqdesc[i].eventindex);
        for(j = 0; j < seqdesc[i].numevents; j++)
        {
            mstudioevent_t seqevent <bgcolor=0x21fe7a, read=ReadString(startof(this) + this.szeventindex)>;
        }
    }

    FSeek(startof(seqdesc[i]) + seqdesc[i].autolayerindex);
    for(j = 0; j < seqdesc[i].numautolayers; j++)
    {
        mstudioautolayer_t autolayers <bgcolor=0x226600>;
    }

    FSeek(startof(seqdesc[i]) + seqdesc[i].weightlistindex);
    seqweightlist_t weightlist <bgcolor=0xe1f27a>;

    struct blendgroup_t
    {
        int16 blends[seqdesc[i].groupsize[0] * seqdesc[i].groupsize[1]];
    };
    
    FSeek(startof(seqdesc[i]) + seqdesc[i].animindexindex);
    blendgroup_t blendgroup <bgcolor=0xffff00>;

    FSeek(startof(seqdesc[i]) + seqdesc[i].activitymodifierindex);
    for(j = 0; j < seqdesc[i].numactivitymodifiers; j++)
    {
        mstudioactivitymodifier_t activitymodifier <bgcolor=0x119900, read=ReadString(startof(this) + this.sznameindex)>;
    }
}

// models
FSeek(mdlHeader.bodypartindex);
mstudiobodyparts_t bodyparts[mdlHeader.numbodyparts] <bgcolor=cGray, read=ReadString(startof(this) + this.sznameindex)>;

local int modelCount = 0;

for (i = 0; i < mdlHeader.numbodyparts; ++i)
{
   modelCount += bodyparts[i].nummodels;
}


if (mdlHeader.version > 49)
    mstudiomodel_t_v52 models[modelCount]<bgcolor=cDkGray>;
else
    mstudiomodel_t models[modelCount]<bgcolor=cDkGray>;




// ik
FSeek(mdlHeader.ikchainindex);
mstudioikchain_t ikchains[mdlHeader.numikchains] <bgcolor=0xe8daef, read=ReadString(startof(this) + this.sznameindex)>;

local int linkCount = 0;

for (i = 0; i < mdlHeader.numikchains; ++i)
{
   linkCount += ikchains[i].numlinks;
}

mstudioiklink_t iklinks[linkCount] <bgcolor=0x7d3c98>;

FSeek(mdlHeader.localikautoplaylockindex);
mstudioiklock_t iklocks[mdlHeader.numlocalikautoplaylocks] <bgcolor=0xe8daef>;

FSeek(mdlHeader.localposeparamindex);
mstudioposeparamdesc_t poseparm[mdlHeader.numlocalposeparameters] <bgcolor=cYellow, read=ReadString(startof(this) + this.sznameindex)>;


// meshes
// can't find an offset for this so it goes here.
local int meshCount = 0;

for (i = 0; i < modelCount; ++i)
{
   meshCount += models[i].nummeshes;
}

mstudiomesh_t meshes[meshCount] <bgcolor=cLtGray>;


// various includes, materials, and groups
FSeek(mdlHeader.includemodelindex);
mstudiomodelgroup_t includemodels[mdlHeader.numincludemodels] <bgcolor=cLtBlue, read=ReadString(startof(this) + this.sznameindex)>;

FSeek(mdlHeader.textureindex);
mstudiotexture_t textures[mdlHeader.numtextures] <bgcolor=cGreen, read=ReadString(startof(this) + this.sznameindex)>;

FSeek(mdlHeader.cdtextureindex);
mstudiotexturedir_t cdmaterials[mdlHeader.numcdtextures] <bgcolor=cDkGreen, read=ReadString(this.sznameindex)>;

FSeek(mdlHeader.skinindex);
mstudioskingroup_t skingroup[mdlHeader.numskinfamilies] <bgcolor=cDkGreen>;

FSeek(mdlHeader.keyvalueindex);
char keyvalues_char[mdlHeader.keyvaluesize] <fgcolor=cLtBlue>;


FSeek(mdlSubHeader.srcbonetransformindex);
mstudiosrcbonetransform_t srcbonetransform[mdlSubHeader.numsrcbonetransform] <bgcolor=cDkGreen, read=ReadString(startof(this) + this.sznameindex)>;

if (mdlSubHeader.linearboneindex > 0)
{
    FSeek(mdlSubHeader.linearboneindex + 408);
    mstudiolinearbone_t linearbone <bgcolor=cGreen>;

    struct mstudiolinearbonedata_t
    {
        if(linearbone.flagsindex > 0)
            uint32 bone_flags[linearbone.numbones];
        if(linearbone.parentindex > 0)
            uint32 bone_parents[linearbone.numbones];
        
        if(linearbone.posindex > 0)
            Vector3 bone_pos[linearbone.numbones];
        if(linearbone.quatindex > 0)
	        Quaternion bone_quat[linearbone.numbones];
        if(linearbone.rotindex > 0)
	        RadianEuler bone_rot[linearbone.numbones];
        
        if(linearbone.posetoboneindex > 0)
            matrix3x4_t bone_poseToBone[linearbone.numbones];

        if(linearbone.posscaleindex > 0)
            Vector3 bone_posscale[linearbone.numbones];
        if(linearbone.rotscaleindex > 0)
	        Vector3 bone_rotscale[linearbone.numbones];
	
        if(linearbone.qalignmentindex > 0)
	        Quaternion bone_qAlignment[linearbone.numbones];
    };

    mstudiolinearbonedata_t linearbonedata <bgcolor=cLtGreen>;
};



if (mdlHeader.version == 52)
{
    // per tri aabb data
    FSeek(startof(mdlSubHeader) + mdlSubHeader.aabbindex);
    pertriheader_t pertrihdr <fgcolor=cDkRed>; // header completely nulled out if unused.
    
    if (mdlSubHeader.numaabb != 0 || mdlSubHeader.numaabb1 != 0 || mdlSubHeader.numaabb2 != 0)
    {
        aabbsection1 unk_bytes1[mdlSubHeader.numaabb] <fgcolor=cRed>;
        aabbsection2 unk_bytes2[mdlSubHeader.numaabb1] <fgcolor=cRed>;
        aabbsection3 unk_bytes3[mdlSubHeader.numaabb2] <fgcolor=cRed>;
    };
};


// unk_index1 always follows this, and always seems to be one byte in front of the string table.


// string table
if(mdlSubHeader.sznameindex == 0)
{        
    FSeek((mdlHeader.surfacepropindex - 1)  + startof(mdlHeader));
    char stringtable[mdlHeader.length - ((mdlHeader.surfacepropindex - 1)  + startof(mdlHeader))] <fgcolor=cLtRed>;
}
else
{
    FSeek((mdlSubHeader.sznameindex - 1)  + startof(mdlSubHeader));
    char stringtable[mdlHeader.length - ((mdlSubHeader.sznameindex - 1)  + startof(mdlSubHeader))] <fgcolor=cLtRed>;
}