//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl
//   Authors: Rika
//   Version: 63
//   Purpose: Bluepoint/Respawn MDL Files
//  Category: Model
// File Mask: *.mdl
//  ID Bytes: 
//   History: 
//------------------------------------------------


#include "../source_math.bt"
#include "../mdl/mdl_structs.bt"
#include "../rmdl/rmdl_structs.bt"

local int i = 0;
local int j = 0;
local int k = 1;
local int x = 0;
local int g = 0;
local int n = 0;


// headers
struct studiohdr_t_v63
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

	Vector illumposition;	// illumination center
	
	Vector hull_min;		// ideal movement hull size
	Vector hull_max;			

	Vector view_bbmin;		// clipping bounding box
	Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    // highest observed: 250
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int deprecated_numflexdesc;
	int deprecated_flexdescindex;
 
    int deprecated_numflexcontrollers;
	int deprecated_flexcontrollerindex;
 
    int deprecated_numflexrules;
	int deprecated_flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int deprecated_nummouths;
	int deprecated_mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents <read=ReadContents(this)>;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
	// implementation specific back pointer to virtual data
	int /* mutable void* */ virtualModel;

	// for demand loaded animation blocks
	int szanimblocknameindex <read=ReadString(this)>;

	int numanimblocks;
	int animblockindex;

	int /* mutable void* */ animblockModel;

	int bonetablebynameindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	int /* void* */ pVertexBase;
	int /* void* */ pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadeDistance;

	int deprecated_numflexcontrollerui;
	int deprecated_flexcontrolleruiindex;

    float flVertAnimFixedPointScale;
    int surfacepropLookup;	// this index must be cached by the loader, not saved in the file
    
	int linearboneindex;
	
	int sourceFilenameOffset; // in v52 not every model has these strings, only four bytes when not present.
};

/*struct studiohdr2_t_v52
{
    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set
	
	int linearboneindex;

	int sznameindex <read=ReadString(startof(mdlSubHeader) + this)>;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;
    
    // for static props (and maybe others)
    // Precomputed Per-Triangle AABB data
    int m_nPerTriAABBIndex;
    int m_nPerTriAABBNodeCount;
    int m_nPerTriAABBLeafCount;
    int m_nPerTriAABBVertCount;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(startof(mdlSubHeader) + mdlSubHeader.unkstringindex)>;

	int reserved[39];
};*/

studiohdr_t_v52 mdlHeader <bgcolor=cLtBlue, read=ReadString(startof(mdlSubHeader) + mdlSubHeader.sznameindex)>;

FSeek(mdlHeader.studiohdr2index);
studiohdr2_t_v52 mdlSubHeader <bgcolor=cDkBlue>;

// bones
FSeek(mdlHeader.boneindex);
mstudiobone_t_v52 bones[mdlHeader.numbones] <bgcolor=cLtGreen, read=ReadString(startof(this) + this.sznameindex)>;

local int jigglebonecount = 0;

local char s_jigglebonename;

for (i = 0; i < mdlHeader.numbones; ++i)
{
    if (bones[i].proctype == 5) {
        jigglebonecount++;
    }
}

mstudiojigglebone_t jigglebones[jigglebonecount] <bgcolor=cGreen>;

FSeek(mdlHeader.localattachmentindex);
mstudioattachment_t attachments[mdlHeader.numlocalattachments] <bgcolor=0xcff5ca, read=Str("%s : %s", ReadString(startof(this) + this.sznameindex), ReadString(startof(bones[this.localbone]) + bones[this.localbone].sznameindex))>;


// hitbox
FSeek(mdlHeader.hitboxsetindex);
mstudiohitboxset_t hboxset[mdlHeader.numhitboxsets] <bgcolor=0xf2e46a, read=ReadString(startof(this) + this.sznameindex)>;

// have to do this because some things actually do have more than one.
local int hboxCount = 0;

for (i = 0; i < mdlHeader.numhitboxsets; ++i)
{
   hboxCount += hboxset[i].numhitboxes;
};

mstudiobbox_t bboxes[hboxCount] <bgcolor=0xa29418, read=ReadString(startof(this) + this.szhitboxnameindex)>;


// more bones
FSeek(mdlHeader.bonetablebynameindex);
ubyte bonebyname[mdlHeader.numbones] <read=ReadString(startof(bones[this]) + bones[this].sznameindex), bgcolor=cDkGreen>;


// animation
/*FSeek(mdlHeader.localanimindex);
if (mdlHeader.version < 49)
    mstudioanimdesc_t_v48 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;
else if(mdlHeader.version == 49)
    mstudioanimdesc_t_v49 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;
else
    mstudioanimdesc_t_v52 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;


// Animation Data
local int numanimboneheader = 0;
local int numsectionanimboneheader = 0;
local int numikrule = 0;
local int numsections = 0;
local int sectionlength = 0;

if(mdlHeader.numlocalanim)
{
    struct {
        for (i = 0; i < mdlHeader.numlocalanim; ++i)
        {
            if((animdesc[i].animblock && animdesc[i].nummovements) || (animdesc[i].animblock && animdesc[i].ikruleindex) || (animdesc[i].animblock && animdesc[i].zeroframeindex) || !animdesc[i].animblock)
            {
                // this clunky mess is so it looks nicer while not puting the start of the struct after then end :D
                FSeek(startof(animdesc[i]));

                if(animdesc[i].animblock && animdesc[i].zeroframeindex)
                    FSeek(startof(animdesc[i]) + animdesc[i].zeroframeindex);
                else if(animdesc[i].animblock && animdesc[i].nummovements)
                    FSeek(startof(animdesc[i]) + animdesc[i].movementindex);
                else if(animdesc[i].animblock && animdesc[i].ikruleindex)
                    FSeek(startof(animdesc[i]) + animdesc[i].ikruleindex);
                else if(!animdesc[i].animblock)
                    FSeek(startof(animdesc[i]) + animdesc[i].animindex);
                struct {
                    local int animidx = i;

                    if(!animdesc[i].animblock)
                    {
                        if(animdesc[i].flags & STUDIO_FRAMEANIM)
                        {
                            if(animdesc[i].sectionindex)
                            {
                                struct {
                                    local int sectionlength = (animdesc[i].numframes / animdesc[i].sectionframes) + 2;
                
                                    FSeek(startof(animdesc[i]) + animdesc[i].sectionindex);
                                    mstudioanimsections_t sectionindexes[sectionlength] <bgcolor=cLtBlue>;
                
                                    for(k = 0; k < sectionlength; k++)
                                    {
                                        if(sectionindexes[k].animindex && !sectionindexes[k].animblock)
                                        {
                                            struct {
                                                FSeek(startof(animdesc[i]) + sectionindexes[k].animindex);
                                                if(mdlHeader.version == 52)
                                                    mstudio_frame_anim_t_v52 frameanim <bgcolor=0x632970>;
                                                else
                                                    mstudio_frame_anim_t frameanim <bgcolor=0x632970>;
                            
                                                byte boneflagarray[mdlHeader.numbones] <read=ReadFrameAnimFlags(this), bgcolor=0xaaaa22>;
                        
                                                local int sectionframes = 0;
    
                                                if(k == (sectionlength - 1))
                                                    sectionframes = animdesc[i].sectionframes;
                                                else
                                                    sectionframes = animdesc[i].sectionframes + 1;
    
                                                if(mdlHeader.version == 52)
                                                {
                                                    FSeek(startof(frameanim) + frameanim.unkdataindex);
                                                    unkframeanimdata_t unkdatatype[mdlHeader.numbones];
                                                }
                        
                                                FSeek(startof(frameanim) + frameanim.constantsoffset);
                                                struct {
                                                    for(j = 0; j < mdlHeader.numbones; j++)
                                                    {
                                                        if((boneflagarray[j] & STUDIO_FRAME_RAWPOS) || (boneflagarray[j] & STUDIO_FRAME_RAWROT) || (mdlHeader.version == 52 && (boneflagarray[j] & STUDIO_FRAME_RAWSCALE_52)))
                                                        {
                                                            struct {
                                                                local int boneidx = j;

                                                                if(boneflagarray[j] & STUDIO_FRAME_RAWROT)
                                                                    Quaternion48 rawrot;
            
                                                                if(boneflagarray[j] & STUDIO_FRAME_RAWPOS)
                                                                    Vector48 rawpos;
            
                                                                if(mdlHeader.version == 52)
                                                                {
                                                                    if(boneflagarray[j] & STUDIO_FRAME_RAWSCALE_52)
                                                                        Vector48 rawscale;
                                                                }
                                                            } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0x321431>;
                                                        }                   
                                                    }
                                                } constantdata;
                        
                                                FSeek(startof(frameanim) + frameanim.frameoffset);
                                                if(frameanim.framelength)
                                                {
                                                    struct {
                                                        for(j = 0; j < mdlHeader.numbones; j++)
                                                        {
                                                            if(mdlHeader.version == 52)
                                                            {
                                                                if((boneflagarray[j] & STUDIO_FRAME_ANIMPOS_52) || (boneflagarray[j] & STUDIO_FRAME_ANIMROT_52) || (boneflagarray[j] & STUDIO_FRAME_ANIMSCALE_52))
                                                                {
                                                                    struct {
                                                                        local int boneidx = j;

                                                                        if(boneflagarray[j] & STUDIO_FRAME_ANIMROT_52)
                                                                            Quaternion48 animrot;
                            
                                                                        if(boneflagarray[j] & STUDIO_FRAME_ANIMPOS_52)
                                                                            Vector48 animpos;                                            
                            
                                                                        if(boneflagarray[j] & STUDIO_FRAME_ANIMSCALE_52)
                                                                            Vector48 animscale;
                                                                    } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0x844b78>;      
                                                                }
                                                            }
                                                            else
                                                            {
                                                                if((boneflagarray[j] & STUDIO_FRAME_ANIMPOS) || (boneflagarray[j] & STUDIO_FRAME_ANIMROT) || (boneflagarray[j] & STUDIO_FRAME_FULLANIMPOS))
                                                                {
                                                                    struct {
                                                                        local int boneidx = j;

                                                                        if(boneflagarray[j] & STUDIO_FRAME_ANIMROT)
                                                                            Quaternion48 animrot;
                            
                                                                        if(boneflagarray[j] & STUDIO_FRAME_ANIMPOS)
                                                                            Vector48 animpos;                                            
                            
                                                                        if(boneflagarray[j] & STUDIO_FRAME_FULLANIMPOS)
                                                                            Vector3 animposfull;
                                                                    } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0x844b78>;      
                                                                }
                                                            }
                                                        }
                                                    } frame[sectionframes];
                        
                                                    Assert(!((sizeof(frame) / sectionframes) != frameanim.framelength), "frame length mismatch");
                                                }
                                            } section;
                                        }
                                    }
                                } sectionframeanimation;
                            }
                            else
                            {
                                struct {
                                    FSeek(startof(animdesc[i]) + animdesc[i].animindex);
                                    if(mdlHeader.version == 52)
                                        mstudio_frame_anim_t_v52 frameanim <bgcolor=0x632970>;
                                    else
                                        mstudio_frame_anim_t frameanim <bgcolor=0x632970>;
                
                                    byte boneflagarray[mdlHeader.numbones] <read=ReadFrameAnimFlags(this), bgcolor=0xaaaa22>;
            
                                    if(mdlHeader.version == 52)
                                    {
                                        FSeek(startof(frameanim) + frameanim.unkdataindex);
                                        unkframeanimdata_t unkdatatype[mdlHeader.numbones];
                                    }
            
                                    FSeek(startof(frameanim) + frameanim.constantsoffset);
                                    struct {
                                        for(j = 0; j < mdlHeader.numbones; j++)
                                        {
                                            if((boneflagarray[j] & STUDIO_FRAME_RAWPOS) || (boneflagarray[j] & STUDIO_FRAME_RAWROT) || (mdlHeader.version == 52 && (boneflagarray[j] & STUDIO_FRAME_RAWSCALE_52)))
                                            {
                                                struct {
                                                    local int boneidx = j;

                                                    if(boneflagarray[j] & STUDIO_FRAME_RAWROT)
                                                        Quaternion48 rawrot;

                                                    if(boneflagarray[j] & STUDIO_FRAME_RAWPOS)
                                                        Vector48 rawpos;

                                                    if(mdlHeader.version == 52)
                                                    {
                                                        if(boneflagarray[j] & STUDIO_FRAME_RAWSCALE_52)
                                                            Vector48 rawscale;
                                                    }

                                                } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0x321431>;
                                            }                   
                                        }
                                    } constantdata;
            
                                    FSeek(startof(frameanim) + frameanim.frameoffset);
                                    if(frameanim.framelength)
                                    {
                                        struct {
                                            for(j = 0; j < mdlHeader.numbones; j++)
                                            {
                                                if(mdlHeader.version == 52)
                                                {
                                                    if((boneflagarray[j] & STUDIO_FRAME_ANIMPOS_52) || (boneflagarray[j] & STUDIO_FRAME_ANIMROT_52) || (boneflagarray[j] & STUDIO_FRAME_ANIMSCALE_52))
                                                    {
                                                        struct {
                                                            local int boneidx = j;

                                                            if(boneflagarray[j] & STUDIO_FRAME_ANIMROT_52)
                                                                Quaternion48 animrot;
                            
                                                            if(boneflagarray[j] & STUDIO_FRAME_ANIMPOS_52)
                                                                Vector48 animpos;                                            
                            
                                                            if(boneflagarray[j] & STUDIO_FRAME_ANIMSCALE_52)
                                                                Vector48 animscale;
                                                        } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0x844b78>;      
                                                    }
                                                }
                                                else
                                                {
                                                    if((boneflagarray[j] & STUDIO_FRAME_ANIMPOS) || (boneflagarray[j] & STUDIO_FRAME_ANIMROT) || (boneflagarray[j] & STUDIO_FRAME_FULLANIMPOS))
                                                    {
                                                        struct {
                                                            local int boneidx = j;

                                                            if(boneflagarray[j] & STUDIO_FRAME_ANIMROT)
                                                                Quaternion48 animrot;
                            
                                                            if(boneflagarray[j] & STUDIO_FRAME_ANIMPOS)
                                                                Vector48 animpos;                                            
                            
                                                            if(boneflagarray[j] & STUDIO_FRAME_FULLANIMPOS)
                                                                Vector3 animposfull;
                                                        } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0x844b78>;      
                                                    }
                                                }
                                            }
                                        } frame[animdesc[i].numframes];
            
                                        Assert(!((sizeof(frame) / animdesc[i].numframes) != frameanim.framelength), "frame length mismatch");
                                    }
                                } frameanimation;
                            }
                        }
                        else
                        {
                            if(animdesc[i].sectionindex)
                            {
                                struct {
                                    local int sectionlength = (animdesc[i].numframes / animdesc[i].sectionframes) + 2;
                
                                    FSeek(startof(animdesc[i]) + animdesc[i].sectionindex);
                                    mstudioanimsections_t sectionindexes[sectionlength] <bgcolor=cLtBlue>;
                
                                    for(k = 0; k < sectionlength; k++)
                                    {
                                        if(sectionindexes[k].animindex && !sectionindexes[k].animblock)
                                        {
                                            struct {
                                                FSeek(startof(animdesc[i]) + sectionindexes[k].animindex);
                                        
                                                for(j = 0; j < mdlHeader.numbones; j++)
                                                {
                                                    struct {
                                                        mstudio_rle_anim_t sectionanimheader <read=ReadString(startof(bones[this.bone]) + bones[this.bone].sznameindex), bgcolor=0x771122>;
                
                                                        Assert(!(sectionanimheader.flags & 0x40), "flag 0x40");
                                                        Assert(!(sectionanimheader.flags & 0x80), "flag 0x80");

                                                        if(sectionanimheader.flags & STUDIO_ANIM_ANIMROT)
                                                        {
                                                            for(g = 0; g < 3; g++)
                                                            {
                                                                if(sectionanimheader.animrot.offset[g])
                                                                {
                                                                    FSeek(startof(sectionanimheader.animrot) + sectionanimheader.animrot.offset[g]);
                                                                    mstudioanimvalue_t animvaluerot <bgcolor=0xFF6622>;
                                                                }
                                                            }
                                                        }
                                                        
                                                        if(sectionanimheader.flags & STUDIO_ANIM_ANIMPOS)
                                                        {
                                                            for(g = 0; g < 3; g++)
                                                            {
                                                                if(sectionanimheader.animpos.offset[g])
                                                                {
                                                                    FSeek(startof(sectionanimheader.animpos) + sectionanimheader.animpos.offset[g]);
                                                                    mstudioanimvalue_t animvaluepos <bgcolor=0xFF6622>;
                                                                }
                                                            }
                                                        }
                
                                                        FSeek(startof(sectionanimheader) + sectionanimheader.nextoffset);
                                                    } section_anim_header_data <read=ReadString(startof(bones[this.sectionanimheader.bone]) + bones[this.sectionanimheader.bone].sznameindex)>;
            
                                                    if(section_anim_header_data.sectionanimheader.nextoffset <= 0)
                                                            break;
                                                }
                                            } section;
                                        }
                                    }
                                } sectionanimation;
                            }
                            else
                            {
                                struct {
                                    FSeek(startof(animdesc[i]) + animdesc[i].animindex);
                
                                    for(j = 0; j < mdlHeader.numbones; j++)
                                    {
                                        struct {
                                            mstudio_rle_anim_t animheader <read=ReadString(startof(bones[this.bone]) + bones[this.bone].sznameindex), bgcolor=cBlue>;
                
                                            Assert(!(animheader.flags & 0x40), "flag 0x40");
                                            Assert(!(animheader.flags & 0x80), "flag 0x80");

                                            if(animheader.flags & STUDIO_ANIM_ANIMROT)
                                            {
                                                for(g = 0; g < 3; g++)
                                                {
                                                    if(animheader.animrot.offset[g])
                                                    {
                                                        FSeek(startof(animheader.animrot) + animheader.animrot.offset[g]);
                                                        mstudioanimvalue_t animvaluerot <bgcolor=0xFF6600>;
                                                    }
                                                }
                                            }
                                            
                                            if(animheader.flags & STUDIO_ANIM_ANIMPOS)
                                            {
                                                for(g = 0; g < 3; g++)
                                                {
                                                    if(animheader.animpos.offset[g])
                                                    {
                                                        FSeek(startof(animheader.animpos) + animheader.animpos.offset[g]);
                                                        mstudioanimvalue_t animvaluepos <bgcolor=0xFF6600>;
                                                    }
                                                }
                                            }

                                            FSeek(startof(animheader) + animheader.nextoffset);     
                                        } anim_header_data <read=ReadString(startof(bones[this.animheader.bone]) + bones[this.animheader.bone].sznameindex)>;
            
                                        if(anim_header_data.animheader.nextoffset <= 0)
                                                break;
                                    }
                                } animation;
                            }
                        }                  
                    }

                    if(animdesc[i].numikrules && animdesc[i].ikruleindex)
                    {
                        FSeek(startof(animdesc[i]) + animdesc[i].ikruleindex);
                        if(mdlHeader.version == 52)
                            mstudioikrule_t_v52 animikrule[animdesc[i].numikrules] <bgcolor=cGreen>;
                        else
                            mstudioikrule_t animikrule[animdesc[i].numikrules] <bgcolor=cGreen>;
                    
                        for(j = 0; j < animdesc[i].numikrules; j++)
                        {
                            if(animikrule[j].compressedikerrorindex)
                            {
                                FSeek(startof(animikrule[j]) + animikrule[j].compressedikerrorindex);
                                mstudiocompressedikerror_t ikcompressederror <bgcolor=cDkGreen>;
                    
                                struct {
                                    for(g = 0; g < 6; g++)
                                    {
                                        if(ikcompressederror.offset[g])
                                        {
                                            FSeek(startof(ikcompressederror) + ikcompressederror.offset[g]);
                                            struct {
                                                mstudioanimvalue_t animvalue <bgcolor=0x228822>;
                    
                                                if(animvalue.num.valid > 0)
                                                    short value[animvalue.num.valid];
                                            } animvalueik;
                                        }
                                    }
                                } compressed_ik_values;
                            }
                    
                            if(animikrule[j].szattachmentindex)
                            {
                                FSeek(startof(animikrule[j]) + animikrule[j].szattachmentindex);
                                struct {
                                    string ikattachment <fgcolor=cGreen>;
                                } attachmentstring;
                            }
                        }
                    }
                    
                    if(mdlHeader.version >= 52 && animdesc[i].framemovementindex)
                    {
                        FSeek(startof(animdesc[i]) + animdesc[i].framemovementindex);
                        mstudioframemovement_t framemovement <bgcolor=cLtGreen>;
                    
                        struct {
                            for(g = 0; g < 4; g++)
                            {
                                if(framemovement.offset[g])
                                {
                                    FSeek(startof(framemovement) + framemovement.offset[g]);
                                    struct {
                                        mstudioanimvalue_t animvalue <bgcolor=0x99CC99>;
                                    
                                        if(animvalue.num.valid > 0)
                                            short value[animvalue.num.valid];
                                    } animvalueik;
                                }
                            }
                        } framemovement_values;
                    }

                    if(animdesc[i].nummovements)
                    {
                        FSeek(startof(animdesc[i]) + animdesc[i].movementindex);
                        mstudiomovement_t movement[animdesc[i].nummovements] <bgcolor=0xaa7722>;
                    }

                    if(animdesc[i].zeroframeindex)
                    {
                        FSeek(startof(animdesc[i]) + animdesc[i].zeroframeindex);

                        struct {
                            for(k = 0; k < animdesc[i].zeroframecount; k++)
                            {
                                struct {
                                    for (j = 0; j < mdlHeader.numbones; j++)
                                    {
                                        if (bones[j].flags & BONE_HAS_SAVEFRAME_POS || bones[j].flags & BONE_HAS_SAVEFRAME_ROT64 || bones[j].flags & BONE_HAS_SAVEFRAME_ROT32)
	                                    {
                                            struct {
                                                local int boneidx = j;

                                                if(bones[j].flags & BONE_HAS_SAVEFRAME_POS)
                                                    Vector48 pos;

                                                if(bones[j].flags & BONE_HAS_SAVEFRAME_ROT64)
                                                    Quaternion64 rot;

                                                if(bones[j].flags & BONE_HAS_SAVEFRAME_ROT32)
                                                    Quaternion32 rot;
                                            } bonedata <read=ReadString(startof(bones[boneidx]) + bones[boneidx].sznameindex), bgcolor=0xffaa88>;
                                        }
                                    }
                                } frame;
                            }

                            if(animdesc[i].numikrules)
                            {
                                FSeek(startof(animdesc[i]) + animdesc[i].ikrulezeroframeindex);
                                mstudioikrulezeroframe_t zeroframeikrule[animdesc[i].numikrules] <bgcolor=cGreen>;
                            }
                        } zeroframe;
                    }
                } animdesc_data <read=ReadString(startof(animdesc[animidx]) + animdesc[animidx].sznameindex)>;
            }
        }      
    } animation_data;
}


// sequence stuff
#include "../mdl/mdl_module_sequences.bt"*/

// unchanged until v54
#include "../mdl/mdl_module_nodes.bt"

// models
#include "../mdl/mdl_module_bodyparts.bt"


// flexes
// depreciated in v52+
if(mdlHeader.version < 52)
{
    if(mdlHeader.numflexdesc)
    {
        FSeek(mdlHeader.flexdescindex);
        mstudioflexdesc_t flexdesc[mdlHeader.numflexdesc] <bgcolor=0x55aaff, read=ReadString(startof(this) + this.szFACSindex)>;
    }
    
    if(mdlHeader.numflexcontrollers)
    {
        FSeek(mdlHeader.flexcontrollerindex);
        mstudioflexcontroller_t flexcontroller[mdlHeader.numflexcontrollers] <bgcolor=0x00aaff, read=ReadString(startof(this) + this.sznameindex)>;
    }
    
    if(mdlHeader.numflexrules)
    {
        FSeek(mdlHeader.flexruleindex);
        mstudioflexrule_t flexrule[mdlHeader.numflexrules] <bgcolor=0x00ccdd>;
    
        local int flexopcount = 0;
    
        for(i = 0; i < mdlHeader.numflexrules; i++)
            flexopcount += flexrule[i].numops;
    
        mstudioflexop_t flexop[flexopcount] <bgcolor=0x88aadd>;
    }
    
    if(mdlHeader.numflexcontrollerui)
    {
        FSeek(mdlHeader.flexcontrolleruiindex);
        mstudioflexcontrollerui_t flexcontrollerui[mdlHeader.numflexcontrollerui] <bgcolor=0x00aaff, read=ReadString(startof(this) + this.sznameindex)>;
    }
}


// ik
if(mdlHeader.numikchains)
{
    FSeek(mdlHeader.ikchainindex);
    struct {
        for(i = 0; i < mdlHeader.numikchains; i++)
        {
            FSeek(mdlHeader.ikchainindex + (sizeof(mstudioikchain_t) * i));
            struct {
                mstudioikchain_t ikchain <bgcolor=0xe8daef, read=ReadString(startof(this) + this.sznameindex)>;
                
                FSeek(startof(ikchain) + ikchain.linkindex);
                mstudioiklink_t iklinks[ikchain.numlinks] <bgcolor=0x7d3c98>;
            } chain <read=ReadString(startof(this.ikchain) + this.ikchain.sznameindex)>;
            
        }
    } ikchains;
}

FSeek(mdlHeader.localikautoplaylockindex);
mstudioiklock_t iklocks[mdlHeader.numlocalikautoplaylocks] <bgcolor=0xe8daef>;

FSeek(mdlHeader.localposeparamindex);
mstudioposeparamdesc_t poseparm[mdlHeader.numlocalposeparameters] <bgcolor=cYellow, read=ReadString(startof(this) + this.sznameindex)>;


// the funny animblocks
FSeek(mdlHeader.animblockindex);
mstudioanimblock_t animblocks[mdlHeader.numanimblocks] <bgcolor=0xdc7633>;

// I do an include file because these are mostly the same across all mdl versions,
// and I really don't wanna have to update every template every time I change something.
#include "../mdl/mdl_module_texturesincludemdl.bt"


// do keyvalues, this remains unchanged in all models since it's just char data.
FSeek(mdlHeader.keyvalueindex);
char keyvalues_char[mdlHeader.keyvaluesize] <fgcolor=cLtBlue>;


//FSeek(mdlSubHeader.srcbonetransformindex);
//mstudiosrcbonetransform_t srcbonetransform[mdlSubHeader.numsrcbonetransform] <bgcolor=cDkGreen, read=ReadString(startof(this) + this.sznameindex)>;


// linear bone table
//#include "../mdl/mdl_module_linearbone.bt"
if (mdlSubHeader.linearboneindex)
{
    FSeek(startof(mdlSubHeader) + mdlSubHeader.linearboneindex);
    mstudiolinearbone_t linearbone <bgcolor=cGreen>;
    
    struct {
        int bone_flags[linearbone.numbones] <read=ReadBoneFlags(this)>;
        int bone_parents[linearbone.numbones] <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>;
        
        Vector3 bone_pos[linearbone.numbones];
        Quaternion bone_quat[linearbone.numbones];
        RadianEuler bone_rot[linearbone.numbones];
        
        matrix3x4_t bone_poseToBone[linearbone.numbones];
        
        // only check this because all others should (as far as I know) be filled out no matter what version (version < 53)
        if(linearbone.posscaleindex)
            Vector3 bone_posscale[linearbone.numbones];
        Vector3 bone_rotscale[linearbone.numbones];
                
        Quaternion bone_qAlignment[linearbone.numbones];
    } linearbonedata <bgcolor=cLtGreen>;
};


if (mdlHeader.version == 52)
{
    // per tri aabb data
    FSeek(startof(mdlSubHeader) + mdlSubHeader.m_nPerTriAABBIndex);
    mstudioaabbheader_t aabbheader <fgcolor=cDkRed>; // header completely nulled out if unused.
    
    if (mdlSubHeader.m_nPerTriAABBNodeCount != 0 || mdlSubHeader.m_nPerTriAABBLeafCount != 0 || mdlSubHeader.m_nPerTriAABBVertCount != 0)
    {
        struct {
            mstudioaabbnode_t aabb_nodes[mdlSubHeader.m_nPerTriAABBNodeCount] <fgcolor=cRed>;
            mstudioaabbleaf_t aabb_leafs[mdlSubHeader.m_nPerTriAABBLeafCount] <fgcolor=cRed>;
            mstudioaabbvert_t aabb_verts[mdlSubHeader.m_nPerTriAABBVertCount] <fgcolor=cRed>;
        } aabb_tree;
    };
};


// string table
//#include "../mdl/mdl_module_stringtable.bt"
if(mdlSubHeader.sznameindex == 0)
{        
    FSeek((mdlHeader.surfacepropindex - 1)  + startof(mdlHeader));
    char stringtable[mdlHeader.length - ((mdlHeader.surfacepropindex - 1)  + startof(mdlHeader))] <fgcolor=cLtRed>;
}
else
{
    FSeek((mdlSubHeader.sznameindex - 1)  + startof(mdlSubHeader));
    char stringtable[mdlHeader.length - ((mdlSubHeader.sznameindex - 1)  + startof(mdlSubHeader))] <fgcolor=cLtRed>;
}