//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl
//   Authors: Rika
//   Version: 53
//   Purpose: Respawn MDL Files
//  Category: Model
// File Mask: *.mdl
//  ID Bytes: 
//   History: 
//------------------------------------------------


#include "../source_math.bt"
#include "../mdl/mdl_structs.bt"
#include "../rmdl/rmdl_structs.bt"
#include "../phy/vphy.bt"
#include "../vtx/vtx.bt"
#include "../vv/vv.bt"

local int i = 0;
local int j = 0;
local int k = 1;
local int x = 0;
local int g = 0;


// headers
studiohdr_t_v53 mdlHeader <bgcolor=cLtBlue, read=ReadString(startof(this) + this.sznameindex)>;


// funny strings that work the same always
#include "../mdl/mdl_v52_module_mayastrings.bt"


// bones
FSeek(mdlHeader.boneindex);
mstudiobone_t_v53 bones[mdlHeader.numbones] <bgcolor=cLtGreen, read=Str("%s : %i : %i", ReadString(startof(this) + this.sznameindex), this.unkindex, this.unkcount)>;

local int jigglebonecount = 0;

for (i = 0; i < mdlHeader.numbones; ++i)
{
    if (bones[i].proctype == 5) {
        jigglebonecount++;      
    }
}

mstudiojigglebone_t jigglebones[jigglebonecount] <bgcolor=cGreen>;

FSeek(mdlHeader.localattachmentindex);
mstudioattachment_t attachments[mdlHeader.numlocalattachments] <bgcolor=0xcff5ca, read=Str("%s : %s", ReadString(startof(this) + this.sznameindex), ReadString(startof(bones[this.localbone]) + bones[this.localbone].sznameindex))>;


// hitbox
FSeek(mdlHeader.hitboxsetindex);
mstudiohitboxset_t hboxset[mdlHeader.numhitboxsets] <bgcolor=0xf2e46a, read=ReadString(startof(this) + this.sznameindex)>;

// have to do this because some things actually do have more than one.
local int hboxCount = 0;

for (i = 0; i < mdlHeader.numhitboxsets; ++i)
{
   hboxCount += hboxset[i].numhitboxes;
};

mstudiobbox_t_v53 hboxes[hboxCount] <bgcolor=0xa29418, read=Str("%s : %s : %i", ReadString(startof(this) + this.szhitboxnameindex), ReadString(startof(this) + this.keyvalueindex), this.critoverride)>;


// more bones
FSeek(mdlHeader.bonetablebynameindex);
mstudiobonenametable_t bonenames <bgcolor=cDkGreen>;


// animation
FSeek(mdlHeader.localanimindex);
mstudioanimdesc_t_v53 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;

if(mdlHeader.numlocalanim)
{
    struct {
        for (i = 0; i < mdlHeader.numlocalanim; ++i)
        {
            struct {
                if(animdesc[i].sectionindex)
                {
                    struct {
                        local int sectionlength = (animdesc[i].numframes / animdesc[i].sectionframes) + 2;
    
                        FSeek(startof(animdesc[i]) + animdesc[i].sectionindex);
                        mstudioanimsections_t_v53 sectionindexes[sectionlength] <bgcolor=cLtBlue>;
    
                        for(k = 0; k < sectionlength; k++)
                        {
                            if(sectionindexes[k].animindex)
                            {
                                struct {
                                    FSeek(startof(animdesc[i]) + sectionindexes[k].animindex);
                            
                                    for(j = 0; j < mdlHeader.numbones; j++)
                                    {
                                        struct {
                                            mstudio_rle_anim_t_v53 sectionanimheader <bgcolor=0x771122>;
    
                                            if(!(sectionanimheader.flags & STUDIO_ANIM_RAWROT_53))
                                            {
                                                for(g = 0; g < 3; g++)
                                                {
                                                    if(sectionanimheader.animrot.offset[g])
                                                    {
                                                        FSeek(startof(sectionanimheader.animrot) + sectionanimheader.animrot.offset[g]);
                                                        mstudioanimvalue_t animvaluerot <bgcolor=0xFF6622>;
                                                    }
                                                }
                                            }
                                            
                                            if(!(sectionanimheader.flags & STUDIO_ANIM_RAWPOS_53))
                                            {
                                                for(g = 0; g < 3; g++)
                                                {
                                                    if(sectionanimheader.animpos.offset[g])
                                                    {
                                                        FSeek(startof(sectionanimheader.animpos) + sectionanimheader.animpos.offset[g]);
                                                        mstudioanimvalue_t animvaluepos <bgcolor=0xFF6622>;
                                                    }
                                                }
                                            }
                                            
                                            if(!(sectionanimheader.flags & STUDIO_ANIM_RAWSCALE_53))
                                            {
                                                for(g = 0; g < 3; g++)
                                                {
                                                    if(sectionanimheader.animscale.offset[g])
                                                    {
                                                        FSeek(startof(sectionanimheader.animscale) + sectionanimheader.animscale.offset[g]);
                                                        mstudioanimvalue_t animvaluescale <bgcolor=0xFF6622>;
                                                    }
                                                }
                                            }
    
                                            FSeek(startof(sectionanimheader) + sectionanimheader.nextoffset);
                                        } section_anim_header_data;

                                        if(section_anim_header_data.sectionanimheader.nextoffset <= 0)
                                                break;
                                    }
                                } section;
                            }
                        }
                    } sectionanimation;
                }
                else
                {
                    struct {
                        FSeek(startof(animdesc[i]) + animdesc[i].animindex);
    
                        for(j = 0; j < mdlHeader.numbones; j++)
                        {
                            struct {
                                mstudio_rle_anim_t_v53 animheader <bgcolor=cBlue>;
    
                                if(!(animheader.flags & STUDIO_ANIM_RAWROT_53))
                                {
                                    for(g = 0; g < 3; g++)
                                    {
                                        if(animheader.animrot.offset[g])
                                        {
                                            FSeek(startof(animheader.animrot) + animheader.animrot.offset[g]);
                                            mstudioanimvalue_t animvaluerot <bgcolor=0xFF6600>;
                                        }
                                    }
                                }
                                
                                if(!(animheader.flags & STUDIO_ANIM_RAWPOS_53))
                                {
                                    for(g = 0; g < 3; g++)
                                    {
                                        if(animheader.animpos.offset[g])
                                        {
                                            FSeek(startof(animheader.animpos) + animheader.animpos.offset[g]);
                                            mstudioanimvalue_t animvaluepos <bgcolor=0xFF6600>;
                                        }
                                    }
                                }
                                
                                if(!(animheader.flags & STUDIO_ANIM_RAWSCALE_53))
                                {
                                    for(g = 0; g < 3; g++)
                                    {
                                        if(animheader.animscale.offset[g])
                                        {
                                            FSeek(startof(animheader.animscale) + animheader.animscale.offset[g]);
                                            mstudioanimvalue_t animvaluescale <bgcolor=0xFF6600>;
                                        }
                                    }
                                }
    
                                FSeek(startof(animheader) + animheader.nextoffset);     
                            } anim_header_data;

                            if(anim_header_data.animheader.nextoffset <= 0)
                                    break;
                        }
                    } animation;
                }
    
                if(animdesc[i].numikrules)
                {
                    FSeek(startof(animdesc[i]) + animdesc[i].ikruleindex);
                    mstudioikrule_t_v53 animikrule[animdesc[i].numikrules] <bgcolor=cGreen>;

                    for(j = 0; j < animdesc[i].numikrules; j++)
                    {
                        if(animikrule[j].compressedikerrorindex)
                        {
                            FSeek(startof(animikrule[j]) + animikrule[j].compressedikerrorindex);
                            mstudiocompressedikerror_t ikcompressederror <bgcolor=cDkGreen>;

                            struct {
                                for(g = 0; g < 6; g++)
                                {
                                    if(ikcompressederror.offset[g])
                                    {
                                        FSeek(startof(ikcompressederror) + ikcompressederror.offset[g]);
                                        mstudioanimvalue_t animvalueik <bgcolor=0x228822>;
                                    }
                                }
                            } compressed_ik_values;
                        }

                        if(animikrule[j].szattachmentindex)
                        {
                            FSeek(startof(animikrule[j]) + animikrule[j].szattachmentindex);
                            struct {
                                string ikattachment <fgcolor=cGreen>;
                            } attachemntstring;
                        }
                    }
                }
            
                if(animdesc[i].compressedikerrorindex)
                {
                    FSeek(startof(animdesc[i]) + animdesc[i].compressedikerrorindex);
                    mstudiocompressedikerror_t_v52 ikcompressederror_v52 <bgcolor=cLtGreen>;

                    struct {
                        for(g = 0; g < 4; g++)
                        {
                            if(ikcompressederror_v52.offset[g])
                            {
                                FSeek(startof(ikcompressederror_v52) + ikcompressederror_v52.offset[g]);
                                mstudioanimvalue_t animvalueik <bgcolor=0x99CC99>;
                            }
                        }
                    } compressed_ik_values;
                }
            } animdesc_data;
        }      
    } animation_data;
}

// sequence stuff
#include "../mdl/mdl_module_sequences.bt"


// unchanged until v54
#include "../mdl/mdl_module_nodes.bt"


// models
FSeek(mdlHeader.bodypartindex);
mstudiobodyparts_t bodyparts[mdlHeader.numbodyparts] <bgcolor=cGray, read=ReadString(startof(this) + this.sznameindex)>;

local int modelCount = 0;

for (i = 0; i < mdlHeader.numbodyparts; ++i)
{
   modelCount += bodyparts[i].nummodels;
};

mstudiomodel_t_v52 models[modelCount] <bgcolor=cDkGray>;

// ik
FSeek(mdlHeader.ikchainindex);
mstudioikchain_t_v53 ikchains[mdlHeader.numikchains] <bgcolor=0xe8daef, read=ReadString(startof(this) + this.sznameindex)>;

local int linkCount = 0;

for (i = 0; i < mdlHeader.numikchains; ++i)
{
   linkCount += ikchains[i].numlinks;
};

mstudioiklink_t iklinks[linkCount] <bgcolor=0x7d3c98>;

FSeek(mdlHeader.localikautoplaylockindex);
mstudioiklock_t iklocks[mdlHeader.numlocalikautoplaylocks] <bgcolor=0xe8daef>;

FSeek(mdlHeader.localposeparamindex);
mstudioposeparamdesc_t poseparm[mdlHeader.numlocalposeparameters] <bgcolor=cYellow, read=ReadString(startof(this) + this.sznameindex)>;


// meshes
// can't find an offset for this so it goes here.
local int meshCount = 0;

for (i = 0; i < modelCount; ++i)
{
   meshCount += models[i].nummeshes;
};

mstudiomesh_t_v53 meshes[meshCount] <bgcolor=cLtGray>;


// rui
#include "../mdl/mdl_v53_module_rui.bt"


// I do an include file because these are mostly the same across all mdl versions,
// and I really don't wanna have to update every template every time I change something.
#include "../mdl/mdl_module_texturesincludemdl.bt"


// do keyvalues, this remains unchanged in all models since it's just char data.
FSeek(mdlHeader.keyvalueindex);
char keyvalues_char[mdlHeader.keyvaluesize] <fgcolor=cLtBlue>;


FSeek(mdlHeader.srcbonetransformindex);
mstudiosrcbonetransform_t srcbonetransform[mdlHeader.numsrcbonetransform] <bgcolor=cDkGreen, read=ReadString(startof(this) + this.sznameindex)>;


// linear bone table
#include "../mdl/mdl_module_linearbone.bt"


// per tri aabb data
FSeek(mdlHeader.aabbindex);
pertriheader_t pertrihdr <fgcolor=cDkRed>; // header completely nulled out if unused.

if (mdlHeader.numaabb || mdlHeader.numaabb1 || mdlHeader.numaabb2)
{
    aabbsection1 unk_bytes1[mdlHeader.numaabb] <fgcolor=cRed>;
    aabbsection2 unk_bytes2[mdlHeader.numaabb1] <fgcolor=cRed>;
    aabbsection3 unk_bytes3[mdlHeader.numaabb2] <fgcolor=cRed>;
};


// string table
local int stringtable_size;

if(mdlHeader.vphysize || mdlHeader.vtxsize)
{
    if(!mdlHeader.vphysize)
        stringtable_size = mdlHeader.vtxindex - (mdlHeader.sznameindex - 1);
    else
        stringtable_size = mdlHeader.vphyindex - (mdlHeader.sznameindex - 1);
}
else
    stringtable_size = mdlHeader.length - (mdlHeader.sznameindex - 1);

FSeek(mdlHeader.sznameindex - 1);
char stringtable[stringtable_size] <fgcolor=cLtRed>;


//=====
// VPHY


struct vphygroup_t
{   
    phyheader_t vphy_header <bgcolor=cLtRed>;
    physection_t vphy_section[vphy_header.numsolids] <optimize=false>;
    
    local int64 charSize = mdlHeader.vphysize; // have to do this locally here because we can't use FileSize()
    
    for (i = 0; i < vphy_header.numsolids; i++)
        charSize -= vphy_section[i].surfaceheader.size + 4;
    
    charSize -= 16;
    
    FSeek(startof(vphy_header) + (mdlHeader.vphysize - charSize));
    char vphy_stringdata[charSize] <fgcolor=cRed>;
};

if (mdlHeader.vphyindex || mdlHeader.vphysize)
{
    FSeek(mdlHeader.vphyindex);
    vphygroup_t vphy;
}

// phy related thing that is merged into phy in apex
if (mdlHeader.vphysize > 0)
{
    local int numunk1 = 0;

    if(mdlHeader.numunkmember1)
        numunk1 = mdlHeader.numunkmember1;
    else
    {
        // we have to do a loop here for some edge case models with weird phys, and by weird I mean
        // more than one section while also having more than one tri header per section
        // examples found to date like this:
        // models\s2s\s2s_malta_gun_animated.mdl
        for(i = 0; i < mdlHeader.numbones; i++)
            numunk1 += bones[i].unkcount;
    }

    FSeek(mdlHeader.unkmemberindex1);
    unkphysectionhdr_t unksechdr[numunk1] <bgcolor=cBlue>;
    struct {
        for(i = 0; i < numunk1; i++)
        {
            struct
            {
                Quaternion unkquat[unksechdr[i].numunk1] <bgcolor=cLtBlue>;
                
                unkphysectiondatatype_t unktype[unksechdr[i].numunk2] <bgcolor=cDkBlue>;
            
                Vector3 vertex[unksechdr[i].numvertices] <bgcolor=cBlue>; // vertices
            } unksecdatachunk <fgcolor=cLtYellow>;
        }
    } unksecdata;
}


//====
// MDL


// this is mdl related (I think) but comes after everything else
#include "../mdl/mdl_v53_module_unk3.bt"


//====
// VTX


struct vtxgroup
{
    FileHeader_t vtx_header <bgcolor=cLtPurple>;
    
    FSeek(startof(vtx_header) + vtx_header.bodyPartOffset);
    BodyPartHeader_t vtx_partheader[vtx_header.numBodyParts] <bgcolor=cPurple>;
    
    
    // gets the total amount of parts.
    local int vtxPartCount = 0;
    
    for (i = 0; i < vtx_header.numBodyParts; ++i)
    {
       vtxPartCount += vtx_partheader[i].numModels;
    };
    
    FSeek(startof(vtx_partheader[0]) + vtx_partheader[0].modelOffset);
    ModelHeader_t vtx_modelheader[vtxPartCount] <bgcolor=cDkPurple>;
    
    
    // gets the total amount of LODs.
    local int vtxLodCount = 0;
    
    for (i = 0; i < vtxPartCount; ++i)
    {
       vtxLodCount += vtx_modelheader[i].numLODs;
    };
    
    FSeek(startof(vtx_modelheader[0]) + vtx_modelheader[0].lodOffset);
    ModelLODHeader_t vtx_lodheader[vtxLodCount] <bgcolor=cLtPurple>;
    
    
    // gets the total amount of LODs.
    local int vtxMeshCount = 0;
    
    for (i = 0; i < vtxLodCount; ++i)
    {
       vtxMeshCount += vtx_lodheader[i].numMeshes;
    };
    
    FSeek(startof(vtx_lodheader[0]) + vtx_lodheader[0].meshOffset);
    MeshHeader_t vtx_meshheader[vtxMeshCount] <bgcolor=cPurple>;
    
    
    // gets the total amount of strip groups.
    local int vtxStripGrpCount = 0;
    
    for (i = 0; i < vtxMeshCount; ++i)
    {
       vtxStripGrpCount += vtx_meshheader[i].numStripGroups;
    };
    
    FSeek(startof(vtx_meshheader[0]) + vtx_meshheader[0].stripGroupHeaderOffset);
    StripGroupHeader_t vtx_stripgrphdr[vtxStripGrpCount] <bgcolor=cDkPurple>;
    
    
    // gets the total amount of strips.
    local int vtxStripCount = 0;
    
    for (i = 0; i < vtxStripGrpCount; ++i)
    {
       vtxStripCount += vtx_stripgrphdr[i].numStrips;
    }
    
    FSeek(startof(vtx_stripgrphdr[0]) + vtx_stripgrphdr[0].stripOffset);
    StripHeader_t vtx_strips[vtxStripCount] <bgcolor=cLtPurple>;
    
    
    for (i = 0; i < vtxStripGrpCount; ++i)
    {
       FSeek(startof(vtx_stripgrphdr[i]) + vtx_stripgrphdr[i].vertOffset);
       vertgroup vtx_vertgroup <optimize=false>;
    };
    
    
    for (i = 0; i < vtxStripGrpCount; ++i)
    {
       FSeek(startof(vtx_stripgrphdr[i]) + vtx_stripgrphdr[i].indexOffset);
       indicegroup vtx_indicegroup <optimize=false>;
    };
    
    
    for (i = 0; i < vtxStripCount; ++i)
    {
       if(vtx_strips[i].boneStateChangeOffset > 0)
        {
            FSeek(startof(vtx_strips[i]) + vtx_strips[i].boneStateChangeOffset);
            bonestategroup vtx_bonestategroup <optimize=false>;
        }
    };
    
    
    FSeek(startof(vtx_header) + vtx_header.materialReplacementListOffset);
    MaterialReplacementListHeader_t materiallist[vtx_header.numLODs] <bgcolor=cDkPurple>;
};

if(mdlHeader.vtxsize)
{
    FSeek(mdlHeader.vtxindex);
    vtxgroup vtx <fgcolor=0xe8daef>;
}


//===
// VV


// vv
struct unkfloatsection
{
    float a;
    float b;
};

struct vvgroup
{
    vertexFileHeader_t vv_header <bgcolor=cYellow>;

    if(vv_header.id == 1447248969)
    {
        FSeek(startof(vv_header) + vv_header.numFixups);
        int unkpervertdata[vv_header.numLODVertexes[0]] <bgcolor=cLtYellow>;
    
        // uv fixup?
        FSeek(startof(vv_header) + vv_header.fixupTableStart);
        unkfloatsection unkfloats[vv_header.numLODVertexes[0]] <bgcolor=cDkYellow>;
    }
    else
    {  
        if(vv_header.fixupTableStart)
        {
            FSeek(startof(vv_header) + vv_header.fixupTableStart);
            vertexFileFixup_t vv_fixup[vv_header.numFixups] <bgcolor=cDkYellow>;
        }
        
        if(vv_header.vertexDataStart)
        {
            FSeek(startof(vv_header) + vv_header.vertexDataStart);
            mstudiovertex_t vv_vert[vv_header.numLODVertexes[0]] <bgcolor=cLtYellow>;
        }
        
        if(vv_header.tangentDataStart)
        {
            FSeek(startof(vv_header) + vv_header.tangentDataStart);
            Vector4 vv_tangent[vv_header.numLODVertexes[0]] <bgcolor=cDkYellow>;
        }
    }
};

// vvd
if (mdlHeader.vvdsize)
{
    FSeek(mdlHeader.vvdindex);
    vvgroup vvd;
}

// vvc
if (mdlHeader.vvcsize)
{
    FSeek(mdlHeader.vvcindex);
    vvgroup vvc;
}