//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl
//   Authors: Rika
//   Version: 53
//   Purpose: Respawn MDL Files
//  Category: Model
// File Mask: *.mdl
//  ID Bytes: 
//   History: 
//------------------------------------------------


#include "../source_math.bt"
#include "../mdl/mdl_structs.bt"
#include "../phy/vphy.bt"
#include "../vtx/vtx.bt"
#include "../vv/vv.bt"

local int i = 0;
local int j = 0;
local int k = 1;
local int x = 0;
local int g = 0;


// headers
studiohdr_t_v53 mdlHeader <bgcolor=cLtBlue, read=ReadString(startof(this) + this.sznameindex)>;


// funny strings that work the same always
#include "../mdl/mdl_v52_module_mayastrings.bt"


// bones
FSeek(mdlHeader.boneindex);
mstudiobone_t_v53 bones[mdlHeader.numbones] <bgcolor=cLtGreen, read=Str("%s : %i", ReadString(startof(this) + this.sznameindex), this.unkid)>;

local int jigglebonecount = 0;

for (i = 0; i < mdlHeader.numbones; ++i)
{
    if (bones[i].proctype == 5) {
        jigglebonecount++;      
    }
}

mstudiojigglebone_t jigglebones[jigglebonecount] <bgcolor=cGreen>;

FSeek(mdlHeader.localattachmentindex);
mstudioattachment_t attachments[mdlHeader.numlocalattachments] <bgcolor=0xcff5ca, read=Str("%s : %s", ReadString(startof(this) + this.sznameindex), ReadString(startof(bones[this.localbone]) + bones[this.localbone].sznameindex))>;


// hitbox
FSeek(mdlHeader.hitboxsetindex);
mstudiohitboxset_t hboxset[mdlHeader.numhitboxsets] <bgcolor=0xf2e46a, read=ReadString(startof(this) + this.sznameindex)>;

// have to do this because some things actually do have more than one.
local int hboxCount = 0;

for (i = 0; i < mdlHeader.numhitboxsets; ++i)
{
   hboxCount += hboxset[i].numhitboxes;
};

mstudiobbox_t_v53 hboxes[hboxCount] <bgcolor=0xa29418, read=Str("%s : %s : %i", ReadString(startof(this) + this.szhitboxnameindex), ReadString(startof(this) + this.keyvalueindex), this.critoverride)>;


// more bones
FSeek(mdlHeader.bonetablebynameindex);
mstudiobonenametable_t bonenames <bgcolor=cDkGreen>;


// animation
FSeek(mdlHeader.localanimindex);
mstudioanimdesc_t_v53 animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;
//NOTE: Using this loop instead of above array so that the "offset" variables are calculated correctly.
/*for (i = 0; i < ; ++i)
{
	mstudioanimdescv53_t animdesc[mdlHeader.numlocalanim] <bgcolor=0xdc7633, read=ReadString(startof(this) + this.sznameindex)>;
}*/


// Animation Data
local int numanimboneheader = 0;
local int numsectionanimboneheader = 0;
local int numikrule = 0;
local int numsections = 0;
local int sectionlength = 0;

for (i = 0; i < mdlHeader.numlocalanim; ++i)
{
    if(animdesc[i].sectionframes > 0)
    {
        FSeek(startof(animdesc[i]) + animdesc[i].sectionindex);
        sectionindexes_t_v53 sectionindexes;
        numsections++;
        sectionlength = (animdesc[i].numframes / animdesc[i].sectionframes) + 2;

        for(j = 0; j < sectionlength; j++)
        {
            FSeek(startof(animdesc[i]) + sectionindexes[numsections - 1].sectionoffsets[j].animindex);

            for (k = 0; k < mdlHeader.numbones; ++k)
            {   
                mstudio_rle_anim_t_v53 sectionanimheader <bgcolor=(this.nextoffset == 0 ? 0xFF1122 : 0x771122 )>;
                numsectionanimboneheader += 1;

                if(!(sectionanimheader[numsectionanimboneheader - 1].flags & STUDIO_ANIM_RAWROT_53))
                {
                    for(g = 0; g < 3; g++)
                    {
                        if(sectionanimheader[numsectionanimboneheader - 1].animrot.offset[g])
                        {
                            FSeek(startof(sectionanimheader[numsectionanimboneheader - 1].animrot) + sectionanimheader[numsectionanimboneheader - 1].animrot.offset[g]);
                            mstudioanimvalue_t animvaluerot <bgcolor=0xFF6622>;
                        }
                    }
                }
                
                if(!(sectionanimheader[numsectionanimboneheader - 1].flags & STUDIO_ANIM_RAWPOS_53))
                {
                    for(g = 0; g < 3; g++)
                    {
                        if(sectionanimheader[numsectionanimboneheader - 1].animpos.offset[g])
                        {
                            FSeek(startof(sectionanimheader[numsectionanimboneheader - 1].animpos) + sectionanimheader[numsectionanimboneheader - 1].animpos.offset[g]);
                            mstudioanimvalue_t animvaluepos <bgcolor=0xFF6622>;
                        }
                    }
                }
                
                if(!(sectionanimheader[numsectionanimboneheader - 1].flags & STUDIO_ANIM_RAWSCALE_53))
                {
                    for(g = 0; g < 3; g++)
                    {
                        if(sectionanimheader[numsectionanimboneheader - 1].animscale.offset[g])
                        {
                            FSeek(startof(sectionanimheader[numsectionanimboneheader - 1].animscale) + sectionanimheader[numsectionanimboneheader - 1].animscale.offset[g]);
                            mstudioanimvalue_t animvaluescale <bgcolor=0xFF6622>;
                        }
                    }
                }

                FSeek(startof(sectionanimheader[numsectionanimboneheader - 1]) + sectionanimheader[numsectionanimboneheader - 1].nextoffset);

                if (sectionanimheader[numsectionanimboneheader - 1].nextoffset <= 0) 
		        {
			        break;
		        }
            };
        };
    }

	if(animdesc[i].sectionframes == 0)
    {
        FSeek(animdesc[i].animindex - animdesc[i].baseptr);
	    for (j = 0; j < mdlHeader.numbones; ++j)
	    {
            
		    mstudio_rle_anim_t_v53 animheader <bgcolor=(this.nextoffset == 0 ? cDkBlue : cBlue )>;
		    numanimboneheader += 1;

            if(!(animheader[numanimboneheader - 1].flags & STUDIO_ANIM_RAWROT_53))
            {
                for(g = 0; g < 3; g++)
                {
                    if(animheader[numanimboneheader - 1].animrot.offset[g])
                    {
                        FSeek(startof(animheader[numanimboneheader - 1].animrot) + animheader[numanimboneheader - 1].animrot.offset[g]);
                        mstudioanimvalue_t animvaluerot <bgcolor=0xFF6600>;
                    }
                }
            }
            
            if(!(animheader[numanimboneheader - 1].flags & STUDIO_ANIM_RAWPOS_53))
            {
                for(g = 0; g < 3; g++)
                {
                    if(animheader[numanimboneheader - 1].animpos.offset[g])
                    {
                        FSeek(startof(animheader[numanimboneheader - 1].animpos) + animheader[numanimboneheader - 1].animpos.offset[g]);
                        mstudioanimvalue_t animvaluepos <bgcolor=0xFF6600>;
                    }
                }
            }
            
            if(!(animheader[numanimboneheader - 1].flags & STUDIO_ANIM_RAWSCALE_53))
            {
                for(g = 0; g < 3; g++)
                {
                    if(animheader[numanimboneheader - 1].animscale.offset[g])
                    {
                        FSeek(startof(animheader[numanimboneheader - 1].animscale) + animheader[numanimboneheader - 1].animscale.offset[g]);
                        mstudioanimvalue_t animvaluescale <bgcolor=0xFF6600>;
                    }
                }
            }

            FSeek(startof(animheader[numanimboneheader - 1]) + animheader[numanimboneheader - 1].nextoffset);
            
		    if (animheader[numanimboneheader - 1].nextoffset <= 0) 
		    {
			    // Read in unused empty data structure at the end of the list.
			    //RAnimBoneHeader animBoneHeaders <bgcolor=cDkBlue>;
			    break;
		    }
	    };
    }

	// Animation IK Rules
	FSeek(animdesc[i].ikruleindex - animdesc[i].baseptr);
	for (j = 0; j < animdesc[i].numikrules; ++j)
	{
		mstudioikrule_t_v53 animikrule <bgcolor=cGreen>;
		numikrule += 1;
	};

    for(j = -animdesc[i].numikrules; j < 0; j++)
    {
        if(animikrule[numikrule + j].compressedikerrorindex > 0)
        {
            FSeek(startof(animikrule[numikrule + j]) + animikrule[numikrule + j].compressedikerrorindex);
            mstudiocompressedikerror_t ikcompressederror <bgcolor=cDkGreen>;
        }
    }

    if(animdesc[i].compressedikerrorindex > 0)
    {
        FSeek(startof(animdesc[i]) + animdesc[i].compressedikerrorindex);
        mstudiocompressedikerror_t_v52 ikcompressederror_v52 <bgcolor=cLtGreen>;
    }

    
};


FSeek(mdlHeader.localseqindex);
mstudioseqdesc_t_v53 seqdesc[mdlHeader.numlocalseq] <bgcolor=0xf0b27a, read=Str("%s : %s", ReadString(startof(this) + this.szlabelindex), ReadString(startof(this) + this.szactivitynameindex))>;

for(i = 0; i < mdlHeader.numlocalseq; i++)
{
    if(seqdesc[i].posekeyindex > 0)
    {
        FSeek(startof(seqdesc[i]) + seqdesc[i].posekeyindex);
        posekey_t posekey <bgcolor=0x55ee00>;
    }

    if(seqdesc[i].numevents > 0)
    {
        FSeek(startof(seqdesc[i]) + seqdesc[i].eventindex);
        for(j = 0; j < seqdesc[i].numevents; j++)
        {
            mstudioevent_t seqevent <bgcolor=0x21fe7a, read=ReadString(startof(this) + this.szeventindex)>;
        }
    }

    FSeek(startof(seqdesc[i]) + seqdesc[i].autolayerindex);
    for(j = 0; j < seqdesc[i].numautolayers; j++)
    {
        mstudioautolayer_t autolayers <bgcolor=0x226600>;
    }

    FSeek(startof(seqdesc[i]) + seqdesc[i].weightlistindex);
    seqweightlist_t weightlist <bgcolor=0xe1f27a>;

    FSeek(startof(seqdesc[i]) + seqdesc[i].animindexindex);
    blendgroup_t blendgroup <bgcolor=0xffff00>;

    FSeek(startof(seqdesc[i]) + seqdesc[i].activitymodifierindex);
    for(j = 0; j < seqdesc[i].numactivitymodifiers; j++)
    {
        mstudioactivitymodifier_t_v53 activitymodifier <bgcolor=0x119900, read=Str("%s : %i", ReadString(startof(this) + this.sznameindex), this.unk)>;
    }
}


// unchanged until v54
#include "../mdl/mdl_module_nodes.bt"


// models
FSeek(mdlHeader.bodypartindex);
mstudiobodyparts_t bodyparts[mdlHeader.numbodyparts] <bgcolor=cGray, read=ReadString(startof(this) + this.sznameindex)>;

local int modelCount = 0;

for (i = 0; i < mdlHeader.numbodyparts; ++i)
{
   modelCount += bodyparts[i].nummodels;
};

mstudiomodel_t_v52 models[modelCount] <bgcolor=cDkGray>;

// ik
FSeek(mdlHeader.ikchainindex);
mstudioikchainv53_t ikchains[mdlHeader.numikchains] <bgcolor=0xe8daef, read=ReadString(startof(this) + this.sznameindex)>;

local int linkCount = 0;

for (i = 0; i < mdlHeader.numikchains; ++i)
{
   linkCount += ikchains[i].numlinks;
};

mstudioiklink_t iklinks[linkCount] <bgcolor=0x7d3c98>;

FSeek(mdlHeader.localikautoplaylockindex);
mstudioiklock_t iklocks[mdlHeader.numlocalikautoplaylocks] <bgcolor=0xe8daef>;

FSeek(mdlHeader.localposeparamindex);
mstudioposeparamdesc_t poseparm[mdlHeader.numlocalposeparameters] <bgcolor=cYellow, read=ReadString(startof(this) + this.sznameindex)>;


// meshes
// can't find an offset for this so it goes here.
local int meshCount = 0;

for (i = 0; i < modelCount; ++i)
{
   meshCount += models[i].nummeshes;
};

mstudiomesh_t meshes[meshCount] <bgcolor=cLtGray>;


// rui
if (mdlHeader.numruimeshes > 0)
{
    FSeek(mdlHeader.ruimeshindex);
    mstudiorruiheader_t ruiheader[mdlHeader.numruimeshes] <fgcolor=cLtGreen>;
    
    FSeek(mdlHeader.ruimeshindex + ruiheader[0].ruimeshindex);
    mstudioruimesh_t ruimesh[mdlHeader.numruimeshes] <fgcolor=cGreen, optimize=false>;
};


// I do an include file because these are mostly the same across all mdl versions,
// and I really don't wanna have to update every template every time I change something.
#include "../mdl/mdl_module_texturesincludemdl.bt"


// do keyvalues, this remains unchanged in all models since it's just char data.
FSeek(mdlHeader.keyvalueindex);
char keyvalues_char[mdlHeader.keyvaluesize] <fgcolor=cLtBlue>;


FSeek(mdlHeader.srcbonetransformindex);
mstudiosrcbonetransform_t srcbonetransform[mdlHeader.numsrcbonetransform] <bgcolor=cDkGreen, read=ReadString(startof(this) + this.sznameindex)>;

if (mdlHeader.linearboneindex > 0)
{
    FSeek(mdlHeader.linearboneindex);
    mstudiolinearbone_t linearbone <bgcolor=cGreen>;
    
    struct mstudiolinearbonedata_t
    {
        if(linearbone.flagsindex > 0)
            int bone_flags[linearbone.numbones];
        if(linearbone.parentindex > 0)
            int bone_parents[linearbone.numbones];
        
        if(linearbone.posindex > 0)
            Vector3 bone_pos[linearbone.numbones];
        if(linearbone.quatindex > 0)
	        Quaternion bone_quat[linearbone.numbones];
        if(linearbone.rotindex > 0)
	        RadianEuler bone_rot[linearbone.numbones];
        
        if(linearbone.posetoboneindex > 0)
            matrix3x4_t bone_poseToBone[linearbone.numbones];

        if(linearbone.posscaleindex > 0)
            Vector3 bone_posscale[linearbone.numbones];
        if(linearbone.rotscaleindex > 0)
	        Vector3 bone_rotscale[linearbone.numbones];
	
        if(linearbone.qalignmentindex > 0)
	        Quaternion bone_qAlignment[linearbone.numbones];
    };

    mstudiolinearbonedata_t linearbonedata <bgcolor=cLtGreen>;

};


struct unksectiondata
{
    

};

// per tri aabb data
FSeek(mdlHeader.aabbindex);
pertriheader_t pertrihdr <fgcolor=cDkRed>; // header completely nulled out if unused.

if (mdlHeader.numaabb != 0 || mdlHeader.numaabb1 != 0 || mdlHeader.numaabb2 != 0)
{
    aabbsection1 unk_bytes1[mdlHeader.numaabb] <fgcolor=cRed>;
    aabbsection2 unk_bytes2[mdlHeader.numaabb1] <fgcolor=cRed>;
    aabbsection3 unk_bytes3[mdlHeader.numaabb2] <fgcolor=cRed>;
};


// unk_index1 always follows this, and always seems to be one byte in front of the string table.


// string table
FSeek(mdlHeader.sznameindex - 1);

local int stringtable_size;

// todo: fix this breaking on anim models
if(mdlHeader.vphysize > 0 || mdlHeader.vtxsize > 0)
{
    if(mdlHeader.vtxsize >= 0 && mdlHeader.vphysize == 0)
    {
        stringtable_size = mdlHeader.vtxindex - (mdlHeader.sznameindex - 1);
    }
    else
    {
        stringtable_size = mdlHeader.vphyindex - (mdlHeader.sznameindex - 1);
    }
}
else
{
    stringtable_size = mdlHeader.unkmemberindex1 - (mdlHeader.sznameindex - 1);
}

char stringtable[stringtable_size] <fgcolor=cLtRed>;


// vphy
FSeek(mdlHeader.vphyindex);

struct vphygroup_t
{   
    phyheader_t vphy_header <bgcolor=cLtRed>;
    // no difference in this and normal section besides reading bones
    physection_t_v53 vphy_section[vphy_header.numsolids] <optimize=false>;
    
    local int64 charSize = mdlHeader.vphysize;
    
    for (i = 0; i < vphy_header.numsolids; i++)
    {
        charSize -= vphy_section[i].surfaceheader.size + 4;
    };
    
    charSize -= 16;
    
    FSeek(startof(vphy_header) + (mdlHeader.vphysize - charSize));
    char vphy_stringdata[charSize] <fgcolor=cRed>;
};


if (mdlHeader.vphyindex > 0)
{
    vphygroup_t vphy;
};


// can't get it working outside here :/
i = 0;

struct unkphysectiondatachunk_t
{
    Quaternion unkquat[unksechdr[i].numunk1] <bgcolor=cLtBlue>;
    
    unkphysectiondatatype_t unktype[unksechdr[i].numunk2] <bgcolor=cDkBlue>;

    Vector3 vertex[unksechdr[i].numvertices] <bgcolor=cBlue>; // vertices

    i++;
};

if (mdlHeader.vphysize > 0)
{
    local int numunk1 = 0;

    if(mdlHeader.numunkmember1 > 0)
    {
        numunk1 = mdlHeader.numunkmember1;
    }
    else
    {
        numunk1 = vphy.vphy_header.numsolids;
    }

    FSeek(mdlHeader.unkmemberindex1);
    unkphysectionhdr_t unksechdr[numunk1] <bgcolor=cBlue>;
    unkphysectiondatachunk_t unksecdatachunk[numunk1] <fgcolor=cLtYellow, optimize=false>;
};

// vtx
FSeek(mdlHeader.vtxindex);

struct vtxgroup
{
    FileHeader_t vtx_header <bgcolor=cLtPurple>;
    
    FSeek(startof(vtx_header) + vtx_header.bodyPartOffset);
    BodyPartHeader_t vtx_partheader[vtx_header.numBodyParts] <bgcolor=cPurple>;
    
    
    // gets the total amount of parts.
    local int vtxPartCount = 0;
    
    for (i = 0; i < vtx_header.numBodyParts; ++i)
    {
       vtxPartCount += vtx_partheader[i].numModels;
    };
    
    FSeek(startof(vtx_partheader[0]) + vtx_partheader[0].modelOffset);
    ModelHeader_t vtx_modelheader[vtxPartCount] <bgcolor=cDkPurple>;
    
    
    // gets the total amount of LODs.
    local int vtxLodCount = 0;
    
    for (i = 0; i < vtxPartCount; ++i)
    {
       vtxLodCount += vtx_modelheader[i].numLODs;
    };
    
    FSeek(startof(vtx_modelheader[0]) + vtx_modelheader[0].lodOffset);
    ModelLODHeader_t vtx_lodheader[vtxLodCount] <bgcolor=cLtPurple>;
    
    
    // gets the total amount of LODs.
    local int vtxMeshCount = 0;
    
    for (i = 0; i < vtxLodCount; ++i)
    {
       vtxMeshCount += vtx_lodheader[i].numMeshes;
    };
    
    FSeek(startof(vtx_lodheader[0]) + vtx_lodheader[0].meshOffset);
    MeshHeader_t vtx_meshheader[vtxMeshCount] <bgcolor=cPurple>;
    
    
    // gets the total amount of strip groups.
    local int vtxStripGrpCount = 0;
    
    for (i = 0; i < vtxMeshCount; ++i)
    {
       vtxStripGrpCount += vtx_meshheader[i].numStripGroups;
    };
    
    FSeek(startof(vtx_meshheader[0]) + vtx_meshheader[0].stripGroupHeaderOffset);
    StripGroupHeader_t vtx_stripgrphdr[vtxStripGrpCount] <bgcolor=cDkPurple>;
    
    
    // gets the total amount of strips.
    local int vtxStripCount = 0;
    
    for (i = 0; i < vtxStripGrpCount; ++i)
    {
       vtxStripCount += vtx_stripgrphdr[i].numStrips;
    }
    
    FSeek(startof(vtx_stripgrphdr[0]) + vtx_stripgrphdr[0].stripOffset);
    StripHeader_t vtx_strips[vtxStripCount] <bgcolor=cLtPurple>;
    
    
    for (i = 0; i < vtxStripGrpCount; ++i)
    {
       FSeek(startof(vtx_stripgrphdr[i]) + vtx_stripgrphdr[i].vertOffset);
       vertgroup vtx_vertgroup <optimize=false>;
    };
    
    
    for (i = 0; i < vtxStripGrpCount; ++i)
    {
       FSeek(startof(vtx_stripgrphdr[i]) + vtx_stripgrphdr[i].indexOffset);
       indicegroup vtx_indicegroup <optimize=false>;
    };
    
    
    for (i = 0; i < vtxStripCount; ++i)
    {
       if(vtx_strips[i].boneStateChangeOffset > 0)
        {
            FSeek(startof(vtx_strips[i]) + vtx_strips[i].boneStateChangeOffset);
            bonestategroup vtx_bonestategroup <optimize=false>;
        }
    };
    
    
    FSeek(startof(vtx_header) + vtx_header.materialReplacementListOffset);
    MaterialReplacementListHeader_t materiallist[vtx_header.numLODs] <bgcolor=cDkPurple>;
};

if (mdlHeader.vtxsize > 0)
    vtxgroup vtx <fgcolor=0xe8daef>;


// vvd
struct vvdgroup
{
    FSeek(mdlHeader.vvdindex);
    vertexFileHeader_t vv_header <bgcolor=cYellow>;

    if(vv_header.fixupTableStart > 0)
    {
        FSeek(startof(vv_header) + vv_header.fixupTableStart);
        vertexFileFixup_t vv_fixup[vv_header.numFixups] <bgcolor=cDkYellow>;
    }
    
    if(vv_header.vertexDataStart > 0)
    {
        FSeek(startof(vv_header) + vv_header.vertexDataStart);
        mstudiovertex_t vv_vert[vv_header.numLODVertexes[0]] <bgcolor=cLtYellow>;
    }
    
    if(vv_header.tangentDataStart > 0)
    {
        FSeek(startof(vv_header) + vv_header.tangentDataStart);
        Vector4 vv_tangent[vv_header.numLODVertexes[0]] <bgcolor=cLtYellow>;
    }
};

if (mdlHeader.vvdsize > 0)
{
    FSeek(mdlHeader.vvdindex);
    vvdgroup vvd;
}

// vvc
struct vvcgroup
{
    // in total the vvc has three ints per vert, not sure what each and everything is for.
    FSeek(mdlHeader.vvcindex);
    vertexFileHeader_t vv_header <bgcolor=cYellow>;

    int unkpervertdata[vv_header.numLODVertexes[0]] <bgcolor=cDkYellow>;\

    // leaving this here however the rest of the data has two ints per vert
    if(vv_header.fixupTableStart > 0)
    {
        FSeek(startof(vv_header) + vv_header.fixupTableStart);
        vertexFileFixup_t vv_fixup[vv_header.numFixups] <bgcolor=cDkYellow>;
    }
};

if (mdlHeader.vvcsize > 0)
{
    FSeek(mdlHeader.vvcindex);
    vvcgroup vvc;
}