//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl/rmdl
//   Authors: Valve, Rika, & Others
//   Version: 48/49/52/53/54
//   Purpose: Valve/Respawn MDL Structs
//  Category: Struct
// File Mask: *.mdl, *.rmdl
//  ID Bytes: 
//   History: 
//------------------------------------------------

#define MAX_NUM_LODS 8

//local int i = 0;

// these are just all structs that I have mostly working/fitting, it does not mean they are correct.
// a lot of these are from either valvedevwiki, the public source sdk 2013 code, and crowbar.


//========
// Headers


// main headers
struct studiohdr_t
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
    int flags;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int nummouths;
	int mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    uint32 virtualModel;
 
    int szanimblocknameindex;	
	int numanimblocks;
	int animblockindex;
	uint32 animblockModel;

	int bonetablebynameindex;
    
    // used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32 pVertexBase;
	uint32 pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	int unused4; // zero out if version < 47

	int numflexcontrollerui;
	int flexcontrolleruiindex;

    float flVertAnimFixedPointScale;
    int surfacepropLookup; // this index must be cached by the loader, not saved in the file
                           // unused in v48 but it isn't worth making another struct over that.
    
	int studiohdr2index;
	
    // NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int unused2;
};

struct studiohdrv52_t
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
    int flags;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int nummouths;
	int mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    uint32 virtualModel;

	int szanimblocknameindex;	
	int numanimblocks;
	int animblockindex;
	uint32 animblockModel;

	int bonetablebynameindex;
    
    // used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32 pVertexBase;
	uint32 pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance;

	int numflexcontrollerui;
	int flexcontrolleruiindex;

    float flVertAnimFixedPointScale;
    int surfacepropLookup;	// this index must be cached by the loader, not saved in the file
    
	// NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int studiohdr2index;
	
	int mayaindex; // in v52 not every model has these strings, only four bytes when not present.
};

struct studiohdrv53_t
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
    int flags;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // mstudiotexture_t
    // short rpak path
	// raw textures
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;

    // this is rui meshes, todo refind mouth count.
    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
    float mass;
	int contents;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    uint32 virtualModel;

    // animblock is either completely cut, this is because they no longer use .ani files.

	int bonetablebynameindex;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance; // set to -1 to never fade. set above 0 if you want it to fade out, distance is in feet.
                        // player/titan models seem to inherit this value from the first model loaded in menus.
                        // works oddly on entities, probably only meant for static props

	int numflexcontrollerui;
	int flexcontrolleruiindex;
    
    // used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
    // might not be correct
	uint32 pVertexBase; // float flVertAnimFixedPointScale;
	uint32 pIndexBase; // int surfacepropLookup;

    // this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
    // doesn't actually need to be written pretty sure, only four bytes when not present.
    // this is not completely true as some models simply have nothing, such as animation models.
	int mayaindex;

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;
	
	int linearboneindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;
    
    // header is still written even if there is no extra data
    // extra data has only been observed when no linear bone data is present.
    int unkmemberindex;
    int unkmembercount;
    int unkmembercount1;
    int unkmembercount2;

    // maybe this is for the string table since it always has one byte padding it?
    // this is probably for some section I haven't seen or a string that hasn't been filled out.
    int unkindex1; // byte before string table start? as of yet unseen member.

    // start of model combination stuff.
    // anis are no longer used from what I can tell, v52s that had them don't in v53.
    int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize;

    // the following 'unks' could actually be indexs.
    // one of these is probably the ANI/IDAG index
    // vertAnimFixedPointScale might be in here but I doubt it.

    // this data block is related to the vphy, if it's not present the data will not be written
    int unkmemberindex1; // section between vphy and vtx.?

    int unk[2];

    int unkindex3; // goes to the same spot as vtx normally.

    int unused1[60]; // god I hope

};

struct studiohdrv54_t
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
    int flags;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // mstudiotexture_t
    // short rpak path
	// raw textures
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    uint32 unkv54; // SubmeshLodsOffset

    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;

    // this is rui meshes, todo refind mouth count.
	int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
    float mass;
	int contents;
	
    // external animations, models, etc.
    // not the same due to streaming, probably mostly unused.
	int numincludemodels; // this works different in apex because rpak models
	int includemodelindex;
    
    uint32 virtualModel;

	int bonetablebynameindex;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance;
	
	float gathersize; // what. from r5r struct

	int unk5v54;

	int boneremapindex;
	int numboneremaps;

	int unk6v54;
    
    // this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
	int mayaindex; // doesn't actually need to be written pretty sure, only four bytes when not present.

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;
	
	int linearboneindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;
    
    int unk2v54[7];

    // maybe this is for the string table since it always has one byte padding it?
    // this is probably for some section I haven't seen or a string that hasn't been filled out.
    int unkindex1; // byte before string table start?

    // this is now used for combined files in rpak, vtx, vvd, and vvc are all combined while vphy is separate.
	// the indexes are added to the offset in the rpak mdl_ header.
    // vphy isn't vphy, looks like a heavily modified vphy.
    int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize;

    // unk3v54[3] is the chunk after following unkindex2's chunk
    int unk3v54[13];

    int unkindex2; // index to chunk after string block

    int unk4v54[3];

};

// sub header
struct studiohdr2_t
{
	// NOTE: For forward compat, make sure any methods in this struct
	// are also available in studiohdr_t so no leaf code ever directly references
	// a studiohdr2_t structure
	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set
	
	int linearboneindex;

	int sznameindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	int reserved[56];
};

struct studiohdr2v52_t
{
    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set
	
	int linearboneindex;

	int sznameindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;
    
    // header is still written even if there is no extra data
    // extra data has only been observed when no linear bone data is present.
    int unkmemberindex;
    int unkmembercount;
    int unkmembercount1;
    int unkmembercount2;

    int unkindex1; // byte before string table start?

	int reserved[39];
};


//=============
// Bone Structs

// bones
struct mstudiobonev48_t
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	// compression scale
	Vector3 posscale;
	Vector3 rotscale;

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone
	
    int surfacepropidx; // index into string tablefor property name

	int contents; // See BSPFlags.h for the contents flags

	int unused[8]; // remove as appropriate
};

struct mstudiobonev49_t
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	// compression scale
	Vector3 posscale;
	Vector3 rotscale;

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone

    int surfacepropidx; // index into string tablefor property name
	
	int contents; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
	int unused[7]; // remove as appropriate
};

struct mstudiobonev52_t
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	
	Vector3 unkvector;
	
	// compression scale
	Vector3 rotscale;

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone

    int surfacepropidx; // index into string tablefor property name
	
	int contents; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
	// compression scale
	Vector3 posscale; // moved here in v52
	
	Vector3 unkvector1;
	
	int unused[1]; // remove as appropriate
};

struct mstudiobonev53_t
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	
	Vector3 unkvector;
	
	// compression scale
	Vector3 posscale;
	Vector3 rotscale;

	Vector3 unkvector1;

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone

    int surfacepropidx; // index into string tablefor property name
	
	int contents; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
	int unkindex; // sometimes there is something here, 0xFFFF in many cases.
				  // probably for adding to an offset in a file.
	
	int unused[7]; // remove as appropriate
};

// v54 is a heavily gutted v53 bone
struct mstudiobonev54_t
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;
	
	Vector3 unkvector; // the same as whatever v53 is

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags;
	int proctype;
    int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone
	
    int surfacepropidx; // index into string tablefor property name

	int contents; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
	int unk[2];
};

// jigglebone
struct mstudiojigglebone_t
{
	uint32 flags;

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

	// flexible params
	float yawStiffness;
	float yawDamping;	
	float pitchStiffness;
	float pitchDamping;	
	float alongStiffness;
	float alongDamping;	

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians
	
	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;
	
	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;	
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

struct mstudiojigglebonev54_t
{
	uint32 flags; // these are different in v54

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

    float unkfloat; // v54 adds an extra value here but otherwise the same

	// flexible params
	float yawStiffness;
	float yawDamping;	
	float pitchStiffness;
	float pitchDamping;	
	float alongStiffness;
	float alongDamping;	

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians
	
	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;
	
	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;	
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

struct mstudioboneflexdriver_t
{
	int m_nBoneIndex;			// Bone to drive flex controller
	int m_nControlCount;		// Number of flex controllers being driven
	int m_nControlIndex;		// Index into data where controllers are (relative to this)

	int unused[3];
};

// not quite right
struct mstudioboneflexdriverv54_t
{
	int m_nBoneIndex;			// Bone to drive flex controller
	int m_nControlCount;		// Number of flex controllers being driven
	int m_nControlIndex;		// Index into data where controllers are (relative to this)

	//int unused[3];
};

// attachments
struct mstudioattachment_t
{
	int sznameindex;
	int		flags;

	int					localbone; // parent bone

	matrix3x4_t			localmatrix; // attachment point

	int					unused[8];
};

struct mstudioattachmentv54_t
{
	int sznameindex;
	int		flags;

	int					localbone; // parent bone

	matrix3x4_t			localmatrix; // attachment point
};

// bone id in alphabetical order
struct mstudiobonenametable_t
{
    byte bone_id[mdlHeader.numbones];
};

// ikchain
struct mstudioikchain_t
{
	int				sznameindex;

	int				linktype;
	int				numlinks;
	int				linkindex;
};

struct mstudioikchainv53_t
{
	int sznameindex;

	int linktype;
	int numlinks;
	int linkindex;
    
    Vector3	kneeDir;
    
    int unk;
};

// ikinfo
struct mstudioiklink_t
{
	uint32 bone;
	Vector3	kneeDir; // ideal bending direction (per link, if applicable), unknown in v53
	Vector3	unused0; // unused in v49
};

// iklock
struct mstudioiklock_t
{
	uint32 chain;
	float flPosWeight;
	float flLocalQWeight;
	uint32 flags;

	uint32 unused[4];
};

// pose parameter desc
struct mstudioposeparamdesc_t
{
	uint32 sznameindex;

	uint32 flags; // ????
	float start; // starting value
	float end; // ending value
	float loop;	// looping range, 0 for no looping, 360 for rotations, etc.
};

// source bone transform
struct mstudiosrcbonetransform_t
{
	int sznameindex;

	matrix3x4_t	pretransform;	
	matrix3x4_t	posttransform;	
};

// linear bone
struct mstudiolinearbone_t	
{
	int numbones;

	int flagsindex;

	int	parentindex;
	
	int	posindex;
	
	int quatindex;
	
	int rotindex;
	
	int posetoboneindex;
	
	int	posscaleindex;
	
	int	rotscaleindex;
	
	int	qalignmentindex;
	
	int unused[6];
};

struct mstudiolinearbonev54_t	
{
    // they cut pos and rot scale, understandable since posscale was never used it tf|2
	int numbones;

	int flagsindex;

	int	parentindex;
	
	int	posindex;
	
	int quatindex;
	
	int rotindex;
	
	int posetoboneindex;
};


//===============
// Hitbox Structs


// hboxset
struct mstudiohitboxset_t
{
	int sznameindex;

	int numhitboxes;
	int hitboxindex;
};

// hit box boxes
struct mstudiobbox_t
{
	int bone;
	int group; // intersection group

	Vector3 bbmin; // bounding box
	Vector3 bbmax;	

	int szhitboxnameindex; // offset to the name of the hitbox.
	int unused[8];
};

struct mstudiobboxv53_t
{
	int bone;
	int group; // intersection group

	Vector3 bbmin; // bounding box
	Vector3 bbmax;	

	uint32 szhitboxnameindex; // offset to the name of the hitbox.
    
    int unk;
    int keyvalueindex; // used for KV names in string block, should be set to hitboxname if kv unneeded.

	int unused[6];
};

struct mstudiobboxv54_t
{
	int bone;
	int group; // intersection group

	Vector3 bbmin; // bounding box
	Vector3 bbmax;	

	int szhitboxnameindex; // offset to the name of the hitbox.
    
    int unk;
    int keyvalueindex; // used for KV names in string block, should be set to hitboxname if kv unneeded.
};


//==================
// Animation Structs

struct RAnimBoneHeader
{
	float TranslationScale;

	byte BoneIndex;

//	RAnimTitanfallBoneFlag BoneFlags;
	byte boneFlags;

	byte Flags2;
	byte Flags3;
	
	short OffsetX;
	short OffsetY;
	short OffsetZ;
	short OffsetL;

	short TranslationX;
	short TranslationY;
	short TranslationZ;

	short ScaleX;
	short ScaleY;
	short ScaleZ;

	uint32 DataSize;

    if (DataSize != 0)
    {
        ubyte unkdata[DataSize - 32];
    };
};

// animdesc, what.
struct mstudioanimdescv48_t
{
	int baseptr;

	int sznameindex;

	float fps; // frames per second	
	int	flags; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

	int unused1[6]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;

	float zeroframestalltime; // saved during read stalls

};

struct mstudioanimdescv49_t
{
	int baseptr;

	int sznameindex;

	float fps; // frames per second	
	int	flags; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

    int ikrulezeroframeindex;

	int unused1[5]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;

	float zeroframestalltime; // saved during read stalls

};

struct mstudioanimdescv53_t
{
	int baseptr;

	int sznameindex;

	float fps; // frames per second	
	int flags; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int nummovements;
	int movementindex;
    
    // pretty sure this gets removed and the anim index is here now.
	//int unused1[4]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;

    // I think these two are swaped
	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;
    float zeroframestalltime; // saved during read stalls

    // ikrulezeroframeindex might be in here
    int unused[4];
};

// sequence descriptions
struct mstudioseqdescv48_t
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector3 bbmin; // per sequence bounding box
	Vector3 bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

	int unused[7];
};

struct mstudioseqdescv49_t
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector3 bbmin; // per sequence bounding box
	Vector3 bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

	int unused[5];
};

struct mstudioseqdescv53_t
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector3 bbmin; // per sequence bounding box
	Vector3 bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

	uint32 unused[8]; // some might be used or they might've just been reseting space like on bones.
};

// demand loaded sequence groups
struct mstudiomodelgroup_t
{
	uint32 szlabelindex; // textual name
	uint32 sznameindex; // file name
};


//===================
// Model/Mesh Structs


// body part index
struct mstudiobodyparts_t
{
	int sznameindex;
	int nummodels;
	int base;
	int modelindex; // index into models array
};

// studio models
struct mstudiomodel_t
{
	char name[64];

	int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)

	int numattachments;
	int attachmentindex;

	int	numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;
    
    // sections of this are removed as needed.
	int unused[10]; // remove as appropriate
};

struct mstudiomodelv53_t
{
	char name[64];

	int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

	int unk[4];

    int unkindex;
    int unkindex1;

    int unused[4];
};

struct mstudiomodelv54_t
{
	char name[64];

	int unkindex; // byte before string block

    // these are probably still used but get written over the name if nothing is set.
    //int type;
	//float boundingradius;

    char name2[8]; // it looks like they write the entire name
                   // then write over it with other values where needed
                   // why.

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	uint32 tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

    // might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

    // same as v53, except trimming the fat
	int unk[4];

    int unkindex;
    int unkindex1;
};

// meshes
struct mstudio_meshvertexdata_t
{
    uint32 unk;    

	int numLODVertexes[MAX_NUM_LODS];
};


struct mstudiomesh_t
{
	int material;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)
	
	int numflexes; // vertex animation
	int flexindex;

	// special codes for material operations
	int materialtype;
	int materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	mstudio_meshvertexdata_t vertexdata;
    
	int unused[8]; // remove as appropriate
};

struct mstudiomeshv54_t
{
	int material;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)
	
	int numflexes; // vertex animation
	int flexindex;


	// special codes for material operations
	int materialtype;
	int materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	mstudio_meshvertexdata_t vertexdata;
    
	int unused[2];
};


//=================
// Material Structs


// cdmaterials
struct mstudiotexturedir_t
{
	uint32 sznameindex; // file name
};

// skin info
struct mstudiotexture_t
{
	int						sznameindex;

	int						flags;
	int						used;
    int						unused1;
	
    int						unused[12];
};

struct mstudiotexturev53_t
{
	int sznameindex;

	int flags;
	int used;
    int unused1;
	
	int unused[7];
};

struct mstudiotexturev54_t
{
	int sznameindex;

	int flags;
	int used;
};

// skin groups
struct mstudioskingroup_t
{
    int16 textureId[mdlHeader.numskinref];
};


//====
// RUI


struct mstudiorruiheader_t
{
    uint32 ruimeshguid; // unsure, it doesn't line up
    uint32 ruimeshindex;
};

// vertex map for a quad
struct mstudioruivertmap_t
{
    // order of vertices for triangles:
    // 1st tri: 1-3-2
    // 2nd tri: 4-2-3

    // three vertex set for base triangle
    // 1-3
    int16 vertstartid;
    int16 vertendid;

    // fourth vert for second triangle
    // 4
    int16 vertfourthid;
};

struct mstudioruivertmapv54_t
{
    // not sure of the order on these
    int16 vertid1;
    int16 vertid2;
    int16 vertid3;
};

struct mstudioruifourthvertv54_t
{
    // not sure of the order on these
    int16 vertid4;
};

struct mstudioruivert_t
{
    int parent; // relative to global mesh parent, assumed

    Vector3 vertexpos; // position of vertex relative to bone
};

struct mstudioruimesface_t
{
    // these values are for the two vertices that are not shared
    // for the other do as such:
    // vertex 2: take x from vextex 1 and y from vextex 4
    // vertex 2: take x from vextex 4 and y from vextex 1

    // normal smd uv, seems to calculate for other values
    Vector2 faceuvmin; // vertex 1
    Vector2 faceuvmax; // vertex 4

    // these could likely be calculated by doing math with a height/width scale
    // scale of the ui element
    Vector2 facescalemin; // vertex 1
    Vector2 facescalemax; // vertex 4
};

struct mstudioruimesh_t
{
    int enablerui; // boolean, 0 off, 1 on
    
    int numvertices; // number of verts
    int numfaces; // number of faces (quads)

    int parentindex; // this gets padding out front of it to even off the struct

    int vertexindex; // offset into smd style vertex data
    int vertmapindex; // offsets into a vertex map for each quad
    int facedataindex; // offset into uv section

    int unk; // zero sometimes, others not.

    char szruimeshname[parentindex - 32]; // have to subtract header to get actual size (padding included)

    int16 parent; // parent bone of mesh

    mstudioruivertmap_t vertexmap[numfaces]; // vertex map for each face
    
    mstudioruivert_t vertex[numvertices];

    mstudioruimesface_t facedata[numfaces];

};

struct mstudioruimeshv54_t
{
    int16 enablerui; // boolean, 0 off, 1 on, might be flags

    //int unk;
    
    int16 numvertices; // number of verts
    int16 numfaces; // number of faces (quads)

    int16 unk;

    int parentindex; // this gets padding out front of it to even off the struct

    int vertexindex; // offset into smd style vertex data

    int fourthvertmapindex; // they now fully map the vertices for each quad

    int vertmapindex; // offsets into a vertex map for each quad

    int facedataindex; // offset into uv section

    char szruimeshname[parentindex - 28]; // have to subtract header to get actual size (padding included)

    int16 parent; // parent bone of mesh

    mstudioruivertmapv54_t vertexmap[numfaces]; // vertex map for each face

    mstudioruifourthvertv54_t fourthvertmap[numfaces];
    
    mstudioruivert_t vertex[numvertices];

    mstudioruimesface_t facedata[numfaces];

};


//========
// Unknown

struct unksectionheader
{
    int unk[15];
};

// struct when linear bone data isn't present
struct unksectionmember1
{
    int unk[5];
};

struct unksectionmember2
{
    int unk[28];
};

struct unksectionmember3
{
    int16 unk;
    int16 unk1;
    int16 unk2;
};

// struct near end of file.
struct unkphysectionhdr_t
{
    int unk; // parent/flags?
    int numunk1; // quaternion, edges?
    int numunk2; // unk member, faces?
    int numvertices; // vector

    int dataindex; // offset to related data chunk
};

struct unkphysectiondatatype_t
{
    Vector3 unkvector; // min/max?
    Vector3 unkvector1; // min/max?
    
    ubyte unk[4]; // flags? four separate bytes?
};