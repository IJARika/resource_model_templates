//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl
//   Authors: Rika
//   Version: 49
//   Purpose: Respawn MDL Files
//  Category: Model
// File Mask: *.mdl
//  ID Bytes: 
//   History: 
//------------------------------------------------


#include "./source_math.bt"
#include "./mdl_structs.bt"


// headers
studiohdr_t mdlHeader <bgcolor=cLtBlue>;
studiohdr2_t mdlSubHeader <bgcolor=cDkBlue>;


// bones
FSeek(mdlHeader.bone_offset);

// check if v48 for different bones :pain:
if (mdlHeader.version < 49)
    mstudiobonev48_t bones[mdlHeader.bone_count] <bgcolor=cLtGreen>; // get names working
else
    mstudiobonev49_t bones[mdlHeader.bone_count] <bgcolor=cLtGreen>; // get names working

local int jigglebonecount = 0;
local int i = 0;

local char s_jigglebonename;

for (i = 0; i < mdlHeader.bone_count; ++i)
{
    if (bones[i].flags == 5) {
        jigglebonecount++;
        
        s_jigglebonename = bones[i].sznameindex;
    }
}

mstudiojigglebone_t jigglebones[jigglebonecount] <bgcolor=cGreen, name = s_jigglebonename>;
mstudioattachment_t attachments[mdlHeader.attachment_count]  <bgcolor=0xcff5ca>;

FSeek(mdlHeader.bonetablename_index);
mstudiobonenametable_t bonenames <bgcolor=cDkGreen>;


// hitbox
FSeek(mdlHeader.hitbox_offset);
mstudiohitboxset_t hboxset[mdlHeader.hitbox_count]  <bgcolor=0xf2e46a>;

// have to do this because some things actually do have more than one.
local int bboxCount = 0;

for (i = 0; i < mdlHeader.hitbox_count; ++i)
{
   bboxCount += hboxset[i].numhitboxes;
}

mstudiobbox_t bboxes[bboxCount]  <bgcolor=0xa29418>;


// animation
FSeek(mdlHeader.localanim_offset);
mstudioanimdesc_t animdesc[mdlHeader.localanim_count] <bgcolor=0xdc7633>;

//FSeek(mdlHeader.localseq_offset);

//mstudioanimdesc_t animseq[1] <bgcolor=0xf0b27a>;


// models
FSeek(mdlHeader.bodypart_offset);
mstudiobodyparts_t bodyparts[mdlHeader.bodypart_count] <bgcolor=cGray>;

local int modelCount = 0;

for (i = 0; i < mdlHeader.bodypart_count; ++i)
{
   modelCount += bodyparts[i].nummodels;
}

mstudiomodel_t models[modelCount]<bgcolor=cDkGray>;


// ik
FSeek(mdlHeader.ikchain_index);
mstudioikchain_t ikchains[mdlHeader.ikchain_count] <bgcolor=0xe8daef>;

local int linkCount = 0;

for (i = 0; i < mdlHeader.ikchain_count; ++i)
{
   linkCount += ikchains[i].numlinks;
}

mstudioiklink_t iklinks[linkCount] <bgcolor=0x7d3c98>;

FSeek(mdlHeader.iklock_index);
mstudioiklock_t iklocks[mdlHeader.iklock_count] <bgcolor=0xe8daef>;

FSeek(mdlHeader.localposeparam_index);
mstudioposeparamdesc_t poseparm[mdlHeader.localposeparam_count] <bgcolor=cYellow>;


// meshes
// can't find an offset for this so it goes here.
local int meshCount = 0;

for (i = 0; i < modelCount; ++i)
{
   meshCount += models[i].nummeshes;
}

mstudiomesh_t meshes[meshCount] <bgcolor=cLtGray>;


// various includes, materials, and groups
FSeek(mdlHeader.includemodel_index);
mstudiomodelgroup_t includemodels[mdlHeader.includemodel_count] <bgcolor=cLtBlue>;

FSeek(mdlHeader.texture_offset);
mstudiotexture_t textures[mdlHeader.texture_count] <bgcolor=cGreen>;

FSeek(mdlHeader.texturedir_offset);
mstudiotexturedir_t cdmaterials[mdlHeader.texturedir_count] <bgcolor=cDkGreen>;

FSeek(mdlHeader.skinreference_index);
mstudioskingroup_t skingroup[mdlHeader.skinrfamily_count] <bgcolor=cDkGreen>;

FSeek(mdlHeader.keyvalue_index);
char keyvalues_char[mdlHeader.keyvalue_size] <fgcolor=cLtBlue>;


FSeek(mdlSubHeader.srcbonetransform_index);
mstudiosrcbonetransform_t srcbonetransform[mdlSubHeader.srcbonetransform_count] <bgcolor=cDkGreen>;

if (mdlSubHeader.linearbone_index > 0)
{
    FSeek(mdlSubHeader.linearbone_index + 408);
    mstudiolinearbone_t linearbone <bgcolor=cGreen>;

    struct mstudiolinearbonedata_t
    {
        if(linearbone.flagsindex > 0)
            uint32 bone_flags[linearbone.numbones];
        if(linearbone.parentindex > 0)
            uint32 bone_parents[linearbone.numbones];
        
        if(linearbone.posindex > 0)
            Vector3 bone_pos[linearbone.numbones];
        if(linearbone.quatindex > 0)
	        Quaternion bone_quat[linearbone.numbones];
        if(linearbone.rotindex > 0)
	        RadianEuler bone_rot[linearbone.numbones];
        
        if(linearbone.posetoboneindex > 0)
            matrix3x4_t bone_poseToBone[linearbone.numbones];

        if(linearbone.posscaleindex > 0)
            Vector3 bone_posscale[linearbone.numbones];
        if(linearbone.rotscaleindex > 0)
	        Vector3 bone_rotscale[linearbone.numbones];
	
        if(linearbone.qalignmentindex > 0)
	        Quaternion bone_qAlignment[linearbone.numbones];
    };

    mstudiolinearbonedata_t linearbonedata <bgcolor=cLtGreen>;
};


// string table
FSeek(mdlSubHeader.sznameindex  + 408);
char stringtable[mdlHeader.dataLength - (mdlSubHeader.sznameindex  + 408)] <fgcolor=cLtRed>;