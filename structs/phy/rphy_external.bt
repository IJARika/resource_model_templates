//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: rphy
//   Authors: Rika & Others
//   Version: 20
//   Purpose: Respawn Physics Files
//  Category: Model
// File Mask: *.phy
//  ID Bytes: 
//   History: 
//------------------------------------------------


#include "../source_math.bt"

local int i = 0;


// a lot of these are from either valvedevwiki, the public source sdk 2013 code, and crowbar.


//=====
// vphy


struct phyheader_t
{
	int size; // Size of this header section (generally 16)
	int id; // version?
	int numsolids; // Number of solids in file
	int checksum; // checksum of source .mdl file (4-bytes)

    int keyvalueindex; // string block or size of data after this member
};

struct phyheader2_t
{
    // respawn using int64 for some reason when it's absolutely unneeded

	int64 size; // Size of this header section (generally 16)
	int64 numsolids; // Number of solids in file
	int64 id; // unsure but this would go with the theme of new stuff.

    int64 keyvalueindex; // string block or size of data after this member
};

struct surfaceheader_t
{
	int64 size; // offsets to associated unknown section
    int64 numsolids;    

    float unkfloat;

    int unk[2];

    float unkfloat1[20];

    int unk;

    // differs slightly from model but should be the mostly same assuming it is one solid.
    // this is PER SOLID so on multi-solid phys this will be smaller than the models
    Vector3 bbmin;
    Vector3 bbmax;

    int unk2[2];
};

struct unktype_t
{
    byte unk[4];

    int unk1[7];
};

struct unktype2_t
{
    byte unk[4];
};

struct unksection_t
{
    int unk;

    float unkfloat[3];

    // same as 'verts' in v53 phy related section
    int64 vertexoffset;
    int64 numvertexes;

    // unk
    int64 unkoffset;
    int64 numunk;    

    // numunk2
    int64 unk2offset;
    int64 numunk2;    

    Vector3 vert[numvertexes] <fgcolor=cLtYellow>;

    unktype_t unktype[numunk] <fgcolor=cLtYellow>;

    unktype2_t unktype2[numunk2] <bgcolor=cDkBlue, fgcolor=cLtYellow>; 
};

struct unksection_t_stub
{
    int unk;

    float unkfloat[3];

    // same as 'verts' in v53 phy related section
    int64 vertexoffset;
    int64 numvertexes;

    // unk
    int64 unkoffset;
    int64 numunk;    

    // numunk2
    int64 unk2offset;
    int64 numunk2;

    // don't do data here as it's gonna be in unk sections
};

struct trianglefaceheader_t
{
    int vertexindex; // from this member to verts
    int parent; // parent bone
    int flags;
    int numfaces;
};

struct trianglevertmap_t
{
    byte faceindex;
    byte unkdata[3];

    int16 vertex1;
    byte unkdata1[2];

    int16 vertex2;
    byte unkdata2[2];

    int16 vertex3;
    byte unkdata3[2];
};

struct phyvertex_t
{
    Vector3 pos; // relative to bone
    int unk;
};

struct phynode_t
{
    int rightnodeindex;
    int convexindex;

    Vector3 center;
    float radius;

    int bboxsize; // volume?
};

phyheader_t vphy_header <bgcolor=cLtRed>;

// this might be a header for unk sections
phyheader2_t vphy_subheader <bgcolor=cRed>;

surfaceheader_t vphy_section[vphy_header.numsolids] <bgcolor=cLtRed, fgcolor=cLtYellow, optimize=false>;

// this is similar to "one solid" normal phy, but done differently
if(vphy_section.numsolids > 1)
{
    unksection_t_stub vphy_section_child[vphy_section.numsolids - 1] <bgcolor=cLtRed>;
}

// this doesn't work properly if the above is true
// needs to inherit values of above children if true
for(i = 0; i < vphy_header.numsolids; i++)
{
    //FSeek(startof(vphy_subheader) + vphy_section[i].size);
    unksection_t unksection <bgcolor=cBlue, optimize=false>;
};



FSeek(vphy_header.keyvalueindex);

local int64 charSize = FileSize() - vphy_header.keyvalueindex;

char vphy_stringdata[charSize] <fgcolor=cRed>;